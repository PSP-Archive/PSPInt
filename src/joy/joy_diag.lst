00000300 NUM_JOY                    00000301 CUR_JOY                    
00000302 RAW_POS                    00000304 RAW_CTR                    
00000306 RAW_MIN                    00000308 RAW_MAX                    
0000030a NRM_POS                    0000030c DISC                       
0000030d NUM_BUT                    0000030e BUTTONS                    
00000310 NUM_HAT                    00000311 HATS                       
00000312 STICSH                     00000000 MEMMAP                     
00000000 MEMMAP.stic                00000080 MEMMAP.voice               
000000f0 MEMMAP.psg1                00000100 MEMMAP.dataram             
000001f0 MEMMAP.psg0                00000200 MEMMAP.backtab             
000002f0 MEMMAP.sysram              00000400 MEMMAP.exec2               
00001000 MEMMAP.exec                00003000 MEMMAP.grom                
00003800 MEMMAP.gram                00003a00 MEMMAP.gram_alias1         
00003c00 MEMMAP.gram_alias2         00003e00 MEMMAP.gram_alias3         
00004000 MEMMAP.stic_alias1         00008000 MEMMAP.stic_alias2         
000001f0 PSG0                       000001f0 PSG0.chn_a_lo              
000001f1 PSG0.chn_b_lo              000001f2 PSG0.chn_c_lo              
000001f3 PSG0.envlp_lo              000001f4 PSG0.chn_a_hi              
000001f5 PSG0.chn_b_hi              000001f6 PSG0.chn_c_hi              
000001f7 PSG0.envlp_hi              000001f8 PSG0.chan_enable           
000001f9 PSG0.noise                 000001fa PSG0.envelope              
000001fb PSG0.chn_a_vol             000001fc PSG0.chn_b_vol             
000001fd PSG0.chn_c_vol             000001fe PSG0.io_port0              
000001ff PSG0.io_port1              000000f0 PSG1                       
000000f0 PSG1.chn_a_lo              000000f1 PSG1.chn_b_lo              
000000f2 PSG1.chn_c_lo              000000f3 PSG1.envlp_lo              
000000f4 PSG1.chn_a_hi              000000f5 PSG1.chn_b_hi              
000000f6 PSG1.chn_c_hi              000000f7 PSG1.envlp_hi              
000000f8 PSG1.chan_enable           000000f9 PSG1.noise                 
000000fa PSG1.envelope              000000fb PSG1.chn_a_vol             
000000fc PSG1.chn_b_vol             000000fd PSG1.chn_c_vol             
000000fe PSG1.io_port0              000000ff PSG1.io_port1              
00000000 PSG                        00000000 PSG.tone_a_on              
00000000 PSG.tone_b_on              00000000 PSG.tone_c_on              
00000000 PSG.noise_a_on             00000000 PSG.noise_b_on             
00000000 PSG.noise_c_on             00000001 PSG.tone_a_off             
00000002 PSG.tone_b_off             00000004 PSG.tone_c_off             
00000008 PSG.noise_a_off            00000010 PSG.noise_b_off            
00000020 PSG.noise_c_off            00000008 PSG.envl_cont              
00000004 PSG.envl_attack            00000002 PSG.envl_alter             
00000001 PSG.envl_hold              00000000 PSG.vol_0                  
00000001 PSG.vol_1                  00000002 PSG.vol_2                  
00000003 PSG.vol_3                  00000004 PSG.vol_4                  
00000005 PSG.vol_5                  00000006 PSG.vol_6                  
00000007 PSG.vol_7                  00000008 PSG.vol_8                  
00000009 PSG.vol_9                  0000000a PSG.vol_10                 
0000000b PSG.vol_11                 0000000c PSG.vol_12                 
0000000d PSG.vol_13                 0000000e PSG.vol_14                 
0000000f PSG.vol_15                 0000003f PSG.vol_envl               
00000000 STIC                       00000000 STIC.mob0_x                
00000001 STIC.mob1_x                00000002 STIC.mob2_x                
00000003 STIC.mob3_x                00000004 STIC.mob4_x                
00000005 STIC.mob5_x                00000006 STIC.mob6_x                
00000007 STIC.mob7_x                00000008 STIC.mob0_y                
00000009 STIC.mob1_y                0000000a STIC.mob2_y                
0000000b STIC.mob3_y                0000000c STIC.mob4_y                
0000000d STIC.mob5_y                0000000e STIC.mob6_y                
0000000f STIC.mob7_y                00000010 STIC.mob0_a                
00000011 STIC.mob1_a                00000012 STIC.mob2_a                
00000013 STIC.mob3_a                00000014 STIC.mob4_a                
00000015 STIC.mob5_a                00000016 STIC.mob6_a                
00000017 STIC.mob7_a                00000018 STIC.mob0_c                
00000019 STIC.mob1_c                0000001a STIC.mob2_c                
0000001b STIC.mob3_c                0000001c STIC.mob4_c                
0000001d STIC.mob5_c                0000001e STIC.mob6_c                
0000001f STIC.mob7_c                00000020 STIC.viden                 
00000021 STIC.mode                  00000028 STIC.colstack              
00000028 STIC.cs0                   00000029 STIC.cs1                   
0000002a STIC.cs2                   0000002b STIC.cs3                   
0000002c STIC.bord                  00000030 STIC.h_delay               
00000031 STIC.v_delay               00000032 STIC.edgemask              
000000ff STIC.mobx_xpos             00000100 STIC.mobx_intr             
00000200 STIC.mobx_visb             00000400 STIC.mobx_xsize            
0000007f STIC.moby_ypos             00000080 STIC.moby_yres             
00000100 STIC.moby_ysize2           00000200 STIC.moby_ysize4           
00000300 STIC.moby_ysize8           00000400 STIC.moby_xflip            
00000800 STIC.moby_yflip            00000000 STIC.moba_fg0              
00000001 STIC.moba_fg1              00000002 STIC.moba_fg2              
00000003 STIC.moba_fg3              00000004 STIC.moba_fg4              
00000005 STIC.moba_fg5              00000006 STIC.moba_fg6              
00000007 STIC.moba_fg7              00001000 STIC.moba_fg8              
00001001 STIC.moba_fg9              00001002 STIC.moba_fgA              
00001003 STIC.moba_fgB              00001004 STIC.moba_fgC              
00001005 STIC.moba_fgD              00001006 STIC.moba_fgE              
00001007 STIC.moba_fgF              000001f8 STIC.moba_card             
00000800 STIC.moba_gram             00002000 STIC.moba_prio             
00000001 STIC.mobc_coll0            00000002 STIC.mobc_coll1            
00000004 STIC.mobc_coll2            00000008 STIC.mobc_coll3            
00000010 STIC.mobc_coll4            00000020 STIC.mobc_coll5            
00000040 STIC.mobc_coll6            00000080 STIC.mobc_coll7            
000000ff STIC.mobc_collmob          00000100 STIC.mobc_collbg           
00000200 STIC.mobc_collbord         00000001 STIC.mask_left             
00000002 STIC.mask_top              00000000 STIC.cs_fg0                
00000001 STIC.cs_fg1                00000002 STIC.cs_fg2                
00000003 STIC.cs_fg3                00000004 STIC.cs_fg4                
00000005 STIC.cs_fg5                00000006 STIC.cs_fg6                
00000007 STIC.cs_fg7                00001000 STIC.cs_fg8                
00001001 STIC.cs_fg9                00001002 STIC.cs_fgA                
00001003 STIC.cs_fgB                00001004 STIC.cs_fgC                
00001005 STIC.cs_fgD                00001006 STIC.cs_fgE                
00001007 STIC.cs_fgF                000007f8 STIC.cs_card               
00000800 STIC.cs_gram               00002000 STIC.cs_advance            
00001000 STIC.cs_colsqr             00000007 STIC.cs_pix0               
00000038 STIC.cs_pix1               000001c0 STIC.cs_pix2               
00002600 STIC.cs_pix3               00000000 STIC.cs_pix0_0             
00000001 STIC.cs_pix0_1             00000002 STIC.cs_pix0_2             
00000003 STIC.cs_pix0_3             00000004 STIC.cs_pix0_4             
00000005 STIC.cs_pix0_5             00000006 STIC.cs_pix0_6             
00000007 STIC.cs_pix0_7             00000000 STIC.cs_pix1_0             
00000008 STIC.cs_pix1_1             00000010 STIC.cs_pix1_2             
00000018 STIC.cs_pix1_3             00000020 STIC.cs_pix1_4             
00000028 STIC.cs_pix1_5             00000030 STIC.cs_pix1_6             
00000038 STIC.cs_pix1_7             00000000 STIC.cs_pix2_0             
00000040 STIC.cs_pix2_1             00000080 STIC.cs_pix2_2             
000000c0 STIC.cs_pix2_3             00000100 STIC.cs_pix2_4             
00000140 STIC.cs_pix2_5             00000180 STIC.cs_pix2_6             
000001c0 STIC.cs_pix2_7             00000000 STIC.cs_pix3_0             
00000200 STIC.cs_pix3_1             00000400 STIC.cs_pix3_2             
00000600 STIC.cs_pix3_3             00002000 STIC.cs_pix3_4             
00002200 STIC.cs_pix3_5             00002400 STIC.cs_pix3_6             
00002600 STIC.cs_pix3_7             00000000 STIC.fb_fg0                
00000001 STIC.fb_fg1                00000002 STIC.fb_fg2                
00000003 STIC.fb_fg3                00000004 STIC.fb_fg4                
00000005 STIC.fb_fg5                00000006 STIC.fb_fg6                
00000007 STIC.fb_fg7                00000000 STIC.fb_bg0                
00000200 STIC.fb_bg1                00000400 STIC.fb_bg2                
00000600 STIC.fb_bg3                00002000 STIC.fb_bg4                
00002200 STIC.fb_bg5                00002400 STIC.fb_bg6                
00002600 STIC.fb_bg7                00001000 STIC.fb_bg8                
00001200 STIC.fb_bg9                00001400 STIC.fb_bgA                
00001600 STIC.fb_bgB                00003000 STIC.fb_bgC                
00003200 STIC.fb_bgD                00003400 STIC.fb_bgE                
00003600 STIC.fb_bgF                000001f8 STIC.fb_card               
00000800 STIC.fb_gram               00000000 C_BLK                      
00000001 C_BLU                      00000002 C_RED                      
00000003 C_TAN                      00000004 C_DGR                      
00000005 C_GRN                      00000006 C_YEL                      
00000007 C_WHT                      00000008 C_GRY                      
00000009 C_CYN                      0000000a C_ORG                      
0000000b C_BRN                      0000000c C_PNK                      
0000000d C_LBL                      0000000e C_YGR                      
0000000f C_PUR                      00000000 X_BLK                      
00000001 X_BLU                      00000002 X_RED                      
00000003 X_TAN                      00000004 X_DGR                      
00000005 X_GRN                      00000006 X_YEL                      
00000007 X_WHT                      00001000 X_GRY                      
00001001 X_CYN                      00001002 X_ORG                      
00001003 X_BRN                      00001004 X_PNK                      
00001005 X_LBL                      00001006 X_YGR                      
00001007 X_PUR                      00000001 _UTIL_MAC                  
00000001 _STIC_MAC                  0000032a __CSTK                     
00000000 __CSTK.GROM_Black          00000001 __CSTK.GROM_Blue           
00000002 __CSTK.GROM_Red            00000003 __CSTK.GROM_Tan            
00000004 __CSTK.GROM_DarkGreen      00000005 __CSTK.GROM_Green          
00000006 __CSTK.GROM_Yellow         00000007 __CSTK.GROM_White          
00000800 __CSTK.GRAM_Black          00000801 __CSTK.GRAM_Blue           
00000802 __CSTK.GRAM_Red            00000803 __CSTK.GRAM_Tan            
00000804 __CSTK.GRAM_DarkGreen      00000805 __CSTK.GRAM_Green          
00000806 __CSTK.GRAM_Yellow         00000807 __CSTK.GRAM_White          
00001800 __CSTK.GRAM_Grey           00001800 __CSTK.GRAM_Gray           
00001801 __CSTK.GRAM_Cyan           00001802 __CSTK.GRAM_Orange         
00001803 __CSTK.GRAM_Brown          00001804 __CSTK.GRAM_Pink           
00001805 __CSTK.GRAM_LightBlue      00001806 __CSTK.GRAM_YellowGreen    
00001807 __CSTK.GRAM_Purple         00000000 __CSTK.GROM_BLK            
00000001 __CSTK.GROM_BLU            00000002 __CSTK.GROM_RED            
00000003 __CSTK.GROM_TAN            00000004 __CSTK.GROM_DGR            
00000005 __CSTK.GROM_GRN            00000006 __CSTK.GROM_YEL            
00000007 __CSTK.GROM_WHT            00000800 __CSTK.GRAM_BLK            
00000801 __CSTK.GRAM_BLU            00000802 __CSTK.GRAM_RED            
00000803 __CSTK.GRAM_TAN            00000804 __CSTK.GRAM_DGR            
00000805 __CSTK.GRAM_GRN            00000806 __CSTK.GRAM_YEL            
00000807 __CSTK.GRAM_WHT            00001800 __CSTK.GRAM_GRY            
00001801 __CSTK.GRAM_CYN            00001802 __CSTK.GRAM_ORG            
00001803 __CSTK.GRAM_BRN            00001804 __CSTK.GRAM_PNK            
00001805 __CSTK.GRAM_LBL            00001806 __CSTK.GRAM_YGR            
00001807 __CSTK.GRAM_PUR            00002000 __CSTK.Adv                 
00002000 __CSTK.Advance             00000000 __CSTK.NoAdv               
00000000 __CSTK.NoAdvance           0000032a __CSQR                     
00000000 __CSQR.p0_Black            00000001 __CSQR.p0_Blue             
00000002 __CSQR.p0_Red              00000003 __CSQR.p0_Tan              
00000004 __CSQR.p0_DarkGreen        00000005 __CSQR.p0_Green            
00000006 __CSQR.p0_Yellow           00000007 __CSQR.p0_Stack            
00000000 __CSQR.p1_Black            00000008 __CSQR.p1_Blue             
00000010 __CSQR.p1_Red              00000018 __CSQR.p1_Tan              
00000020 __CSQR.p1_DarkGreen        00000028 __CSQR.p1_Green            
00000030 __CSQR.p1_Yellow           00000038 __CSQR.p1_Stack            
00000000 __CSQR.p2_Black            00000040 __CSQR.p2_Blue             
00000080 __CSQR.p2_Red              000000c0 __CSQR.p2_Tan              
00000100 __CSQR.p2_DarkGreen        00000140 __CSQR.p2_Green            
00000180 __CSQR.p2_Yellow           000001c0 __CSQR.p2_Stack            
00000000 __CSQR.p3_Black            00000200 __CSQR.p3_Blue             
00000400 __CSQR.p3_Red              00000600 __CSQR.p3_Tan              
00002000 __CSQR.p3_DarkGreen        00002200 __CSQR.p3_Green            
00002400 __CSQR.p3_Yellow           00002600 __CSQR.p3_Stack            
00000000 __CSQR.p0_BLK              00000001 __CSQR.p0_BLU              
00000002 __CSQR.p0_RED              00000003 __CSQR.p0_TAN              
00000004 __CSQR.p0_DGR              00000005 __CSQR.p0_GRN              
00000006 __CSQR.p0_YEL              00000007 __CSQR.p0_STK              
00000000 __CSQR.p1_BLK              00000008 __CSQR.p1_BLU              
00000010 __CSQR.p1_RED              00000018 __CSQR.p1_TAN              
00000020 __CSQR.p1_DGR              00000028 __CSQR.p1_GRN              
00000030 __CSQR.p1_YEL              00000038 __CSQR.p1_STK              
00000000 __CSQR.p2_BLK              00000040 __CSQR.p2_BLU              
00000080 __CSQR.p2_RED              000000c0 __CSQR.p2_TAN              
00000100 __CSQR.p2_DGR              00000140 __CSQR.p2_GRN              
00000180 __CSQR.p2_YEL              000001c0 __CSQR.p2_STK              
00000000 __CSQR.p3_BLK              00000200 __CSQR.p3_BLU              
00000400 __CSQR.p3_RED              00000600 __CSQR.p3_TAN              
00002000 __CSQR.p3_DGR              00002200 __CSQR.p3_GRN              
00002400 __CSQR.p3_YEL              00002600 __CSQR.p3_STK              
0000032a __FGBG                     00000000 __FGBG.f_Black             
00000001 __FGBG.f_Blue              00000002 __FGBG.f_Red               
00000003 __FGBG.f_Tan               00000004 __FGBG.f_DarkGreen         
00000005 __FGBG.f_Green             00000006 __FGBG.f_Yellow            
00000007 __FGBG.f_White             00000000 __FGBG.b_Black             
00000200 __FGBG.b_Blue              00000400 __FGBG.b_Red               
00000600 __FGBG.b_Tan               00002000 __FGBG.b_DarkGreen         
00002200 __FGBG.b_Green             00002400 __FGBG.b_Yellow            
00002600 __FGBG.b_White             00001000 __FGBG.b_Grey              
00001000 __FGBG.b_Gray              00001200 __FGBG.b_Cyan              
00001400 __FGBG.b_Orange            00001600 __FGBG.b_Brown             
00003000 __FGBG.b_Pink              00003200 __FGBG.b_LightBlue         
00003400 __FGBG.b_YellowGreen       00003600 __FGBG.b_Purple            
00000000 __FGBG.f_BLK               00000001 __FGBG.f_BLU               
00000002 __FGBG.f_RED               00000003 __FGBG.f_TAN               
00000004 __FGBG.f_DGR               00000005 __FGBG.f_GRN               
00000006 __FGBG.f_YEL               00000007 __FGBG.f_WHT               
00000000 __FGBG.b_BLK               00000200 __FGBG.b_BLU               
00000400 __FGBG.b_RED               00000600 __FGBG.b_TAN               
00002000 __FGBG.b_DGR               00002200 __FGBG.b_GRN               
00002400 __FGBG.b_YEL               00002600 __FGBG.b_WHT               
00001000 __FGBG.b_GRY               00001200 __FGBG.b_CYN               
00001400 __FGBG.b_ORG               00001600 __FGBG.b_BRN               
00003000 __FGBG.b_PNK               00003200 __FGBG.b_LBL               
00003400 __FGBG.b_YGR               00003600 __FGBG.b_PUR               
00000800 __FGBG.GRAM                00000000 __FGBG.GROM                
00000001 _GFX_MAC                   00000001 _PRINT_MAC                 
00005000 ROMHDR                     0000500d ZERO                       
0000502a MAIN                       0000500f ONES                       
00005014 TITLE                      00000000 EL_NUM_JOY                 
00000001 EL_GET_GEO                 00000002 EL_RAW_POS                 
00000003 EL_RAW_MIN                 00000004 EL_RAW_MAX                 
00000005 EL_RAW_CTR                 00000006 EL_GET_XY                  
00000007 EL_GET_BTN                 00000008 EL_GET_HAT                 
00005168 FILLZERO                   000050d8 ISR                        
00005073 TITLE.ok                   00005144 PRINT.FLS                  
000050f6 DO_EL                      00005096 TITLE.got_joy              
00005098 TITLE.loop                 00005139 GET_RAW                    
000050e4 DISP_PAIR                  000051b7 HEX16                      
000050f7 DO_EL.1                    00005103 DO_EL.failed               
00005164 CLRSCR                     00005144 PRINT                      
00005145 PRINT.LS                   0000514f PRINT.S                    
00005148 PRINT.FLP                  00005149 PRINT.LP                   
0000514a PRINT.P                    0000514b PRINT.R                    
0000515a PRINT.1st                  00005154 PRINT.tloop                
00005169 FILLMEM                    0000516e _PW10                      
00005174 PRNUM16                    ???????? _NO_PRNUM16.l              
00005174 PRNUM16.l                  00005175 PRNUM16.l1                 
00005181 PRNUM16.z2                 ???????? _NO_PRNUM16.b              
0000517c PRNUM16.b                  0000517d PRNUM16.b1                 
0000517f PRNUM16.z                  00005180 PRNUM16.z1                 
00005192 PRNUM16.lblnk              0000518f PRNUM16.llp                
0000519c PRNUM16.ldone              0000519d PRNUM16.digit              
000051a6 PRNUM16.dig1               000051b4 PRNUM16.done               
???????? PRNUM32                    ???????? _WITH_PRNUM32              
000051a7 PRNUM16.cont               000051a9 PRNUM16.spcl               
000051a6 PRNUM16.nxdig              000051a9 PRNUM16.div                
000051cb HEX16.start                000051bb HEX12                      
000051bd HEX12M                     000051c1 HEX8                       
000051c2 HEX8M                      000051c6 HEX4                       
000051c9 HEX4M                      000051d0 HEX16.loop                 
000051de HEX16.digit                
			;; ======================================================================== ;;
			;;  Joystick Diagnostics Program                                            ;;
			;;  Uses EMU_LINK interface to query jzIntv for raw joystick parameters     ;;
			;; ======================================================================== ;;

			;* ======================================================================== *;
			;*  This program is free software; you can redistribute it and/or modify    *;
			;*  it under the terms of the GNU General Public License as published by    *;
			;*  the Free Software Foundation; either version 2 of the License, or       *;
			;*  (at your option) any later version.                                     *;
			;*                                                                          *;
			;*  This program is distributed in the hope that it will be useful,         *;
			;*  but WITHOUT ANY WARRANTY; without even the implied warranty of          *;
			;*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU       *;
			;*  General Public License for more details.                                *;
			;*                                                                          *;
			;*  You should have received a copy of the GNU General Public License       *;
			;*  along with this program; if not, write to the Free Software             *;
			;*  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.               *;
			;* ======================================================================== *;
			;*                   Copyright (c) 2005, Joseph Zbiciak                     *;
			;* ======================================================================== *;


			            ROMW    16              ; Use 16-bit ROM width

 0x300                              ORG     $300, $300, "-RWBN"
 0x300                  NUM_JOY     RMB     1
 0x301                  CUR_JOY     RMB     1
 0x302                  RAW_POS     RMB     2
 0x304                  RAW_CTR     RMB     2
 0x306                  RAW_MIN     RMB     2
 0x308                  RAW_MAX     RMB     2
 0x30a                  NRM_POS     RMB     2
 0x30c                  DISC        RMB     1
 0x30d                  NUM_BUT     RMB     1
 0x30e                  BUTTONS     RMB     2
 0x310                  NUM_HAT     RMB     1
 0x311                  HATS        RMB     1
 0x312                  STICSH      RMB     24


			;; ======================================================================== ;;
			;;  Macros and definitions                                                  ;;
			;; ======================================================================== ;;
			            INCLUDE "library/gimini.asm"
			;;==========================================================================;;
			;; GIMINI structure definitions.  Defines the memory map and peripherals.   ;;
			;;==========================================================================;;

			;* ======================================================================== *;
			;*  This program is free software; you can redistribute it and/or modify    *;
			;*  it under the terms of the GNU General Public License as published by    *;
			;*  the Free Software Foundation; either version 2 of the License, or       *;
			;*  (at your option) any later version.                                     *;
			;*                                                                          *;
			;*  This program is distributed in the hope that it will be useful,         *;
			;*  but WITHOUT ANY WARRANTY; without even the implied warranty of          *;
			;*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU       *;
			;*  General Public License for more details.                                *;
			;*                                                                          *;
			;*  You should have received a copy of the GNU General Public License       *;
			;*  along with this program; if not, write to the Free Software             *;
			;*  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.               *;
			;* ======================================================================== *;
			;*                   Copyright (c) 2000, Joseph Zbiciak                     *;
			;* ======================================================================== *;



			;; ======================================================================== ;;
			;;  Overall Memory Map                                                      ;;
			;;  MEMMAP -- Structure containing overall system memory map.               ;;
			;; ======================================================================== ;;
 0x0                    MEMMAP          STRUCT  0
 0x0                    @@stic          EQU     $0000 ;..$003F  ; Standard Television Interface Circuit
 0x80                   @@voice         EQU     $0080 ;..$0081  ; Voice Synthesizer
 0xf0                   @@psg1          EQU     $00F0 ;..$00FF  ; Secondary Programmable Sound Gen.
 0x100                  @@dataram       EQU     $0100 ;..$01EF  ; 8-bit Data RAM
 0x1f0                  @@psg0          EQU     $01F0 ;..$01FF  ; Primary Programmable Sound Generator
 0x200                  @@backtab       EQU     $0200 ;..$02EF  ; 16-bit Display RAM
 0x2f0                  @@sysram        EQU     $02F0 ;..$035F  ; 16-bit System RAM (incl. Stack)
 0x400                  @@exec2         EQU     $0400 ;..$04FF  ; Executive ROM expansion
 0x1000                 @@exec          EQU     $1000 ;..$1FFF  ; Executive ROM
 0x3000                 @@grom          EQU     $3000 ;..$37FF  ; Graphics ROM
 0x3800                 @@gram          EQU     $3800 ;..$39FF  ; Graphics RAM
 0x3a00                 @@gram_alias1   EQU     $3A00 ;..$3BFF  ; Graphics RAM alias 
 0x3c00                 @@gram_alias2   EQU     $3C00 ;..$3DFF  ; Graphics RAM alias
 0x3e00                 @@gram_alias3   EQU     $3E00 ;..$3FFF  ; Graphics RAM alias
 0x4000                 @@stic_alias1   EQU     $4000 ;..$403F  ; STIC alias (incomplete decode)
 0x8000                 @@stic_alias2   EQU     $8000 ;..$803F  ; STIC alias (incomplete decode)
			                ENDS



			;;==========================================================================;;
			;; AY8914 Programmable Sound Generator Register Definitions.                ;;
			;;                                                                          ;;
			;; PSG0 -- Primary PSG in the Gimini Console.                               ;;
			;; PSG1 -- Secondary PSG, available when expansion is attached.             ;;
			;; PSG  -- Constants and bitfields common to both PSG's.                    ;;
			;;                                                                          ;;
			;; Each PSG contains the following set of registers:                        ;;
			;;                                                                          ;;
			;;     Register pairs:                                                      ;;
			;;                                                                          ;;
			;;       7   6   5   4   3   2   1   0 | 7   6   5   4   3   2   1   0      ;;
			;;     +---------------+---------------|-------------------------------+    ;;
			;;  R4 |    unused     |                Channel A Period               | R0 ;;
			;;     +---------------+---------------|-------------------------------+    ;;
			;;  R5 |    unused     |                Channel B Period               | R1 ;;
			;;     +---------------+---------------|-------------------------------+    ;;
			;;  R6 |    unused     |                Channel C Period               | R2 ;;
			;;     +---------------+---------------|-------------------------------+    ;;
			;;  R7 |                        Envelope Period                        | R3 ;;
			;;     +-------------------------------|-------+-----------------------+    ;;
			;;                                                                          ;;
			;;     Single registers:                                                    ;;
			;;                                                                          ;;
			;;         7       6       5       4       3       2       1       0        ;;
			;;     +---------------+-----------------------+-----------------------+    ;;
			;;     | I/O Port Dir  |    Noise Enables      |     Tone Enables      |    ;;
			;;  R8 |   0   |   0   |   C   |   B   |   A   |   C   |   B   |   A   |    ;;
			;;     +-------+-------+-------+-------+-------+-------+-------+-------+    ;;
			;;  R9 |            unused     |              Noise Period             |    ;;
			;;     +-----------------------+-------+-------+-------+-------+-------+    ;;
			;;     |                               |   Envelope Characteristics    |    ;;
			;; R10 |            unused             | CONT  |ATTACK | ALTER | HOLD  |    ;;
			;;     +---------------+---------------+-------+-------+-------+-------+    ;;
			;; R11 |    unused     | A Envl Select |    Channel A Volume Level     |    ;;
			;;     +---------------+---------------+-------------------------------+    ;;
			;; R12 |    unused     | B Envl Select |    Channel B Volume Level     |    ;;
			;;     +---------------+---------------+-------------------------------+    ;;
			;; R13 |    unused     | C Envl Select |    Channel C Volume Level     |    ;;
			;;     +---------------+---------------+-------------------------------+    ;;
			;;                                                                          ;;
			;;==========================================================================;;

			                ;;==========================================================;;
			                ;; Primary PSG in the main console.                         ;;
			                ;;==========================================================;;
 0x1f0                  PSG0            STRUCT  $01F0

			                ;;----------------------------------------------------------;;
			                ;; Register address definitions                             ;;
			                ;;----------------------------------------------------------;;
 0x1f0                  @@chn_a_lo      EQU     $ + 0   ; Channel A period, lower 8 bits of 12
 0x1f1                  @@chn_b_lo      EQU     $ + 1   ; Channel B period, lower 8 bits of 12
 0x1f2                  @@chn_c_lo      EQU     $ + 2   ; Channel C period, lower 8 bits of 12
 0x1f3                  @@envlp_lo      EQU     $ + 3   ; Envelope period,  lower 8 bits of 16

 0x1f4                  @@chn_a_hi      EQU     $ + 4   ; Channel A period, upper 4 bits of 12
 0x1f5                  @@chn_b_hi      EQU     $ + 5   ; Channel B period, upper 4 bits of 12
 0x1f6                  @@chn_c_hi      EQU     $ + 6   ; Channel C period, upper 4 bits of 12
 0x1f7                  @@envlp_hi      EQU     $ + 7   ; Envelope period,  upper 8 bits of 16

 0x1f8                  @@chan_enable   EQU     $ + 8   ; Channel enables (bits 3-5 noise, 0-2 tone)
 0x1f9                  @@noise         EQU     $ + 9   ; Noise period (5 bits)
 0x1fa                  @@envelope      EQU     $ + 10  ; Envelope type/trigger (4 bits)

 0x1fb                  @@chn_a_vol     EQU     $ + 11  ; Channel A volume / Envelope select (6 bits)
 0x1fc                  @@chn_b_vol     EQU     $ + 12  ; Channel B volume / Envelope select (6 bits)
 0x1fd                  @@chn_c_vol     EQU     $ + 13  ; Channel C volume / Envelope select (6 bits)

 0x1fe                  @@io_port0      EQU     $ + 14  ; I/O port 0 (8 bits)
 0x1ff                  @@io_port1      EQU     $ + 15  ; I/O port 1 (8 bits)

			                ENDS

			                ;;==========================================================;;
			                ;; Secondary PSG in the expansion unit.                     ;;
			                ;;==========================================================;;
 0xf0                   PSG1            STRUCT  $00F0

			                ;;----------------------------------------------------------;;
			                ;; Register address definitions                             ;;
			                ;;----------------------------------------------------------;;
 0xf0                   @@chn_a_lo      EQU     $ + 0   ; Channel A period, lower 8 bits of 12
 0xf1                   @@chn_b_lo      EQU     $ + 1   ; Channel B period, lower 8 bits of 12
 0xf2                   @@chn_c_lo      EQU     $ + 2   ; Channel C period, lower 8 bits of 12
 0xf3                   @@envlp_lo      EQU     $ + 3   ; Envelope period,  lower 8 bits of 16

 0xf4                   @@chn_a_hi      EQU     $ + 4   ; Channel A period, upper 4 bits of 12
 0xf5                   @@chn_b_hi      EQU     $ + 5   ; Channel B period, upper 4 bits of 12
 0xf6                   @@chn_c_hi      EQU     $ + 6   ; Channel C period, upper 4 bits of 12
 0xf7                   @@envlp_hi      EQU     $ + 7   ; Envelope period,  upper 8 bits of 16

 0xf8                   @@chan_enable   EQU     $ + 8   ; Channel enables (bits 3-5 noise, 0-2 tone)
 0xf9                   @@noise         EQU     $ + 9   ; Noise period (5 bits)
 0xfa                   @@envelope      EQU     $ + 10  ; Envelope type/trigger (4 bits)

 0xfb                   @@chn_a_vol     EQU     $ + 11  ; Channel A volume / Envelope select (6 bits)
 0xfc                   @@chn_b_vol     EQU     $ + 12  ; Channel B volume / Envelope select (6 bits)
 0xfd                   @@chn_c_vol     EQU     $ + 13  ; Channel C volume / Envelope select (6 bits)

 0xfe                   @@io_port0      EQU     $ + 14  ; I/O port 0 (8 bits)
 0xff                   @@io_port1      EQU     $ + 15  ; I/O port 1 (8 bits)

			                ENDS

			                ;;==========================================================;;
			                ;; Useful Constants / Bit-field definitions.                ;;
			                ;;==========================================================;;
 0x0                    PSG             STRUCT  $0000   ; Constants, etc. common to both PSGs.

			                ;;----------------------------------------------------------;;
			                ;; Bits to OR together for Channel Enable word              ;;
			                ;;----------------------------------------------------------;;
 0x0                    @@tone_a_on     EQU     00000000b   
 0x0                    @@tone_b_on     EQU     00000000b
 0x0                    @@tone_c_on     EQU     00000000b
 0x0                    @@noise_a_on    EQU     00000000b
 0x0                    @@noise_b_on    EQU     00000000b
 0x0                    @@noise_c_on    EQU     00000000b

 0x1                    @@tone_a_off    EQU     00000001b
 0x2                    @@tone_b_off    EQU     00000010b
 0x4                    @@tone_c_off    EQU     00000100b
 0x8                    @@noise_a_off   EQU     00001000b
 0x10                   @@noise_b_off   EQU     00010000b
 0x20                   @@noise_c_off   EQU     00100000b

			                ;;----------------------------------------------------------;;
			                ;; Bits to OR together for Envelope Type                    ;;
			                ;;----------------------------------------------------------;;
 0x8                    @@envl_cont     EQU     00001000b   ; Continue
 0x4                    @@envl_attack   EQU     00000100b   ; Attack (vs. Decay)
 0x2                    @@envl_alter    EQU     00000010b   ; Alternate
 0x1                    @@envl_hold     EQU     00000001b   ; Hold

			                ;;----------------------------------------------------------;;
			                ;; Volume levels                                            ;;
			                ;;----------------------------------------------------------;;
 0x0                    @@vol_0         EQU     0
 0x1                    @@vol_1         EQU     1
 0x2                    @@vol_2         EQU     2
 0x3                    @@vol_3         EQU     3
 0x4                    @@vol_4         EQU     4
 0x5                    @@vol_5         EQU     5
 0x6                    @@vol_6         EQU     6
 0x7                    @@vol_7         EQU     7
 0x8                    @@vol_8         EQU     8
 0x9                    @@vol_9         EQU     9
 0xa                    @@vol_10        EQU     10
 0xb                    @@vol_11        EQU     11
 0xc                    @@vol_12        EQU     12
 0xd                    @@vol_13        EQU     13
 0xe                    @@vol_14        EQU     14
 0xf                    @@vol_15        EQU     15
 0x3f                   @@vol_envl      EQU     63

			                ENDS

			;;==========================================================================;;
			;; AY8900 Standard Television Interface Circuit                             ;;
			;;                                                                          ;;
			;; STIC -- Register definitions, constants and bitfields                    ;;
			;;                                                                          ;;
			;; The Standard Television Interface Circuit provides a method for placing  ;;
			;; characters and graphics on the screen.  It provides a 20x12 matrix of    ;;
			;; background 'cards'.  Each card contains an 8x8 tile of pixels.  It also  ;;
			;; provides 8 movable objects (refered to here as MOBs).                    ;;
			;;                                                                          ;;
			;; MOB controls: (Note: 'mob' is MOB number (0 - 7))                        ;;
			;;  mob + $00   -- X position, and some attribute bits.                     ;;
			;;  mob + $08   -- Y position, and some attribute bits.                     ;;
			;;  mob + $10   -- Character definition, more attribute bits.               ;;
			;;  mob + $18   -- Collision information.                                   ;;
			;;                                                                          ;;
			;; Display Mode controls:                                                   ;;
			;;  $20         -- Display enable (must be written during vert blank.)      ;;
			;;  $21         -- Graphics mode (write sets FGBG, read sets Color Stack)   ;;
			;;                                                                          ;;
			;; Color Stack and Border Color controls:                                   ;;
			;;  $28..$2B    -- Color stack entries 0..3                                 ;;
			;;  $2C         -- Screen border color                                      ;;
			;;                                                                          ;;
			;; Display framing controls:                                                ;;
			;;  $30         -- Pixel column delay (0..7)                                ;;
			;;  $31         -- Pixel row delay (0..7)                                   ;;
			;;  $32         -- Edge masking (bit 0 masks left, bit 1 masks top)         ;;
			;;                                                                          ;;
			;; Color Set                                                                ;;
			;;       Primary Color Set                Pastel Color Set                  ;;
			;;    ------------------------       -----------------------------          ;;
			;;     0 Black   4 Dark Green          8 Grey     12 Pink                   ;;
			;;     1 Blue    5 Green               9 Cyan     13 Light Blue             ;;
			;;     2 Red     6 Yellow             10 Orange   14 Yellow-Green           ;;
			;;     3 Tan     7 White              11 Brown    15 Purple                 ;;
			;;                                                                          ;;
			;;==========================================================================;;
 0x0                    STIC            STRUCT  $0000

			;;--------------------------------------------------------------------------;;
			;; MOB Controls                                                             ;;
			;;                                                                          ;;
			;; X Register layout:                                                       ;;
			;;                                                                          ;;
			;;    13   12   11   10    9    8    7    6    5    4    3    2    1    0   ;;
			;;  +----+----+----+----+----+----+----+----+----+----+----+----+----+----+ ;;
			;;  | ?? | ?? | ?? | X  |VISB|INTR|            X Coordinate               | ;;
			;;  |    |    |    |SIZE|    |    |             (0 to 255)                | ;;
			;;  +----+----+----+----+----+----+----+----+----+----+----+----+----+----+ ;;
			;;                                                                          ;;
			;; Y Register layout:                                                       ;;
			;;                                                                          ;;
			;;    13   12   11   10    9    8    7    6    5    4    3    2    1    0   ;;
			;;  +----+----+----+----+----+----+----+----+----+----+----+----+----+----+ ;;
			;;  | ?? | ?? | Y  | X  | Y  | Y  |YRES|          Y Coordinate            | ;;
			;;  |    |    |FLIP|FLIP|SIZ4|SIZ2|    |           (0 to 127)             | ;;
			;;  +----+----+----+----+----+----+----+----+----+----+----+----+----+----+ ;;
			;;                                                                          ;;
			;; A Register layout:                                                       ;;
			;;                                                                          ;;
			;;    13   12   11   10    9    8    7    6    5    4    3    2    1    0   ;;
			;;  +----+----+----+----+----+----+----+----+----+----+----+----+----+----+ ;;
			;;  |PRIO| FG |GRAM|      GRAM/GROM Card # (0 to 255)      |   FG Color   | ;;
			;;  |    |bit3|GROM|     (bits 9, 10 ignored for GRAM)     |   Bits 0-2   | ;;
			;;  +----+----+----+----+----+----+----+----+----+----+----+----+----+----+ ;;
			;;                                                                          ;;
			;; C Register layout:                                                       ;;
			;;                                                                          ;;
			;;    13   12   11   10    9    8    7    6    5    4    3    2    1    0   ;;
			;;  +----+----+----+----+----+----+----+----+----+----+----+----+----+----+ ;;
			;;  | ?? | ?? | ?? | ?? |COLL|COLL|COLL|COLL|COLL|COLL|COLL|COLL|COLL|COLL| ;;
			;;  |    |    |    |    |BORD| BG |MOB7|MOB6|MOB5|MOB4|MOB3|MOB2|MOB1|MOB0| ;;
			;;  +----+----+----+----+----+----+----+----+----+----+----+----+----+----+ ;;
			;;--------------------------------------------------------------------------;;

 0x0                    @@mob0_x        EQU     $00 + 0     ; MOB 0 X position, XSIZE/VIS attributes
 0x1                    @@mob1_x        EQU     $00 + 1     ; MOB 1 X position, XSIZE/VIS attributes
 0x2                    @@mob2_x        EQU     $00 + 2     ; MOB 2 X position, XSIZE/VIS attributes
 0x3                    @@mob3_x        EQU     $00 + 3     ; MOB 3 X position, XSIZE/VIS attributes
 0x4                    @@mob4_x        EQU     $00 + 4     ; MOB 4 X position, XSIZE/VIS attributes
 0x5                    @@mob5_x        EQU     $00 + 5     ; MOB 5 X position, XSIZE/VIS attributes
 0x6                    @@mob6_x        EQU     $00 + 6     ; MOB 6 X position, XSIZE/VIS attributes
 0x7                    @@mob7_x        EQU     $00 + 7     ; MOB 7 X position, XSIZE/VIS attributes

 0x8                    @@mob0_y        EQU     $08 + 0     ; MOB 0 Y pos'n, YRES/YSIZE/XFLIP/YFLIP
 0x9                    @@mob1_y        EQU     $08 + 1     ; MOB 1 Y pos'n, YRES/YSIZE/XFLIP/YFLIP
 0xa                    @@mob2_y        EQU     $08 + 2     ; MOB 2 Y pos'n, YRES/YSIZE/XFLIP/YFLIP
 0xb                    @@mob3_y        EQU     $08 + 3     ; MOB 3 Y pos'n, YRES/YSIZE/XFLIP/YFLIP
 0xc                    @@mob4_y        EQU     $08 + 4     ; MOB 4 Y pos'n, YRES/YSIZE/XFLIP/YFLIP
 0xd                    @@mob5_y        EQU     $08 + 5     ; MOB 5 Y pos'n, YRES/YSIZE/XFLIP/YFLIP
 0xe                    @@mob6_y        EQU     $08 + 6     ; MOB 6 Y pos'n, YRES/YSIZE/XFLIP/YFLIP
 0xf                    @@mob7_y        EQU     $08 + 7     ; MOB 7 Y pos'n, YRES/YSIZE/XFLIP/YFLIP

 0x10                   @@mob0_a        EQU     $10 + 0     ; MOB 0 Color, Card #, Priority
 0x11                   @@mob1_a        EQU     $10 + 1     ; MOB 1 Color, Card #, Priority
 0x12                   @@mob2_a        EQU     $10 + 2     ; MOB 2 Color, Card #, Priority
 0x13                   @@mob3_a        EQU     $10 + 3     ; MOB 3 Color, Card #, Priority
 0x14                   @@mob4_a        EQU     $10 + 4     ; MOB 4 Color, Card #, Priority
 0x15                   @@mob5_a        EQU     $10 + 5     ; MOB 5 Color, Card #, Priority
 0x16                   @@mob6_a        EQU     $10 + 6     ; MOB 6 Color, Card #, Priority
 0x17                   @@mob7_a        EQU     $10 + 7     ; MOB 7 Color, Card #, Priority

 0x18                   @@mob0_c        EQU     $18 + 0     ; MOB 0 Collision detect
 0x19                   @@mob1_c        EQU     $18 + 1     ; MOB 1 Collision detect
 0x1a                   @@mob2_c        EQU     $18 + 2     ; MOB 2 Collision detect
 0x1b                   @@mob3_c        EQU     $18 + 3     ; MOB 3 Collision detect
 0x1c                   @@mob4_c        EQU     $18 + 4     ; MOB 4 Collision detect
 0x1d                   @@mob5_c        EQU     $18 + 5     ; MOB 5 Collision detect
 0x1e                   @@mob6_c        EQU     $18 + 6     ; MOB 6 Collision detect
 0x1f                   @@mob7_c        EQU     $18 + 7     ; MOB 7 Collision detect

			                ;;----------------------------------------------------------;;
			                ;; Display Mode Controls                                    ;;
			                ;;----------------------------------------------------------;;
 0x20                   @@viden         EQU     $20         ; Display Enable (write during vblank)
 0x21                   @@mode          EQU     $21         ; Mode select 

			                ;;----------------------------------------------------------;;
			                ;; Color Stack and Display Border Color Controls            ;;
			                ;;----------------------------------------------------------;;
 0x28                   @@colstack      EQU     $28         ; Base of the color stack
 0x28                   @@cs0           EQU     $28 + 0     ; Color Stack 0
 0x29                   @@cs1           EQU     $28 + 1     ; Color Stack 1
 0x2a                   @@cs2           EQU     $28 + 2     ; Color Stack 2
 0x2b                   @@cs3           EQU     $28 + 3     ; Color Stack 3
 0x2c                   @@bord          EQU     $2C         ; Border color

			                ;;----------------------------------------------------------;;
			                ;; Display Framing Controls                                 ;;
			                ;;----------------------------------------------------------;;
 0x30                   @@h_delay       EQU     $30         ; Horizontal delay (0 - 7 pixels)
 0x31                   @@v_delay       EQU     $31         ; Vertical delay (0 - 7 pixels)
 0x32                   @@edgemask      EQU     $32         ; Edge masking

			                ;;----------------------------------------------------------;;
			                ;; Useful bitfields/constants/masks for MOBS                ;;
			                ;;----------------------------------------------------------;;
 0xff                   @@mobx_xpos     EQU     00000011111111b     ; MOB XREG: X position
 0x100                  @@mobx_intr     EQU     00000100000000b     ; MOB XREG: Interaction
 0x200                  @@mobx_visb     EQU     00001000000000b     ; MOB XREG: Visibility
 0x400                  @@mobx_xsize    EQU     00010000000000b     ; MOB XREG: Horiz 2x magnification

 0x7f                   @@moby_ypos     EQU     00000001111111b     ; MOB YREG: Y position
 0x80                   @@moby_yres     EQU     00000010000000b     ; MOB YREG: Y res. (8 or 16 rows)
 0x100                  @@moby_ysize2   EQU     00000100000000b     ; MOB YREG: Vert 2x magnification
 0x200                  @@moby_ysize4   EQU     00001000000000b     ; MOB YREG: Vert 4x magnification
 0x300                  @@moby_ysize8   EQU     00001100000000b     ; MOB YREG: 8x mag (sets 4x & 2x)
 0x400                  @@moby_xflip    EQU     00010000000000b     ; MOB YREG: Flip horizontally
 0x800                  @@moby_yflip    EQU     00100000000000b     ; MOB YREG: Flip vertically

 0x0                    @@moba_fg0      EQU     00000000000000b     ; MOB AREG: Foreground color =  0
 0x1                    @@moba_fg1      EQU     00000000000001b     ; MOB AREG: Foreground color =  1
 0x2                    @@moba_fg2      EQU     00000000000010b     ; MOB AREG: Foreground color =  2
 0x3                    @@moba_fg3      EQU     00000000000011b     ; MOB AREG: Foreground color =  3
 0x4                    @@moba_fg4      EQU     00000000000100b     ; MOB AREG: Foreground color =  4
 0x5                    @@moba_fg5      EQU     00000000000101b     ; MOB AREG: Foreground color =  5
 0x6                    @@moba_fg6      EQU     00000000000110b     ; MOB AREG: Foreground color =  6
 0x7                    @@moba_fg7      EQU     00000000000111b     ; MOB AREG: Foreground color =  7
 0x1000                 @@moba_fg8      EQU     01000000000000b     ; MOB AREG: Foreground color =  8
 0x1001                 @@moba_fg9      EQU     01000000000001b     ; MOB AREG: Foreground color =  9
 0x1002                 @@moba_fgA      EQU     01000000000010b     ; MOB AREG: Foreground color = 10
 0x1003                 @@moba_fgB      EQU     01000000000011b     ; MOB AREG: Foreground color = 11
 0x1004                 @@moba_fgC      EQU     01000000000100b     ; MOB AREG: Foreground color = 12
 0x1005                 @@moba_fgD      EQU     01000000000101b     ; MOB AREG: Foreground color = 13
 0x1006                 @@moba_fgE      EQU     01000000000110b     ; MOB AREG: Foreground color = 14
 0x1007                 @@moba_fgF      EQU     01000000000111b     ; MOB AREG: Foreground color = 15
 0x1f8                  @@moba_card     EQU     00000111111000b     ; MOB AREG: Card # mask
 0x800                  @@moba_gram     EQU     00100000000000b     ; MOB AREG: GRAM card select
 0x2000                 @@moba_prio     EQU     10000000000000b     ; MOB AREG: Priority 
			                                            ;           (above/below bkgnd)

 0x1                    @@mobc_coll0    EQU     00000000000001b     ; MOB CREG: Collision w/ MOB #0
 0x2                    @@mobc_coll1    EQU     00000000000010b     ; MOB CREG: Collision w/ MOB #1
 0x4                    @@mobc_coll2    EQU     00000000000100b     ; MOB CREG: Collision w/ MOB #2
 0x8                    @@mobc_coll3    EQU     00000000001000b     ; MOB CREG: Collision w/ MOB #3
 0x10                   @@mobc_coll4    EQU     00000000010000b     ; MOB CREG: Collision w/ MOB #4
 0x20                   @@mobc_coll5    EQU     00000000100000b     ; MOB CREG: Collision w/ MOB #5
 0x40                   @@mobc_coll6    EQU     00000001000000b     ; MOB CREG: Collision w/ MOB #6
 0x80                   @@mobc_coll7    EQU     00000010000000b     ; MOB CREG: Collision w/ MOB #7
 0xff                   @@mobc_collmob  EQU     00000011111111b     ; MOB CREG: Coll w/ any MOB (mask)
 0x100                  @@mobc_collbg   EQU     00000100000000b     ; MOB CREG; Coll w/ background
 0x200                  @@mobc_collbord EQU     00001000000000b     ; MOB CREG; Coll w/ background

			                ;;----------------------------------------------------------;;
			                ;; Useful bits for Edge Masking.                            ;;
			                ;;----------------------------------------------------------;;
 0x1                    @@mask_left     EQU     00000000000001b     ; Edge mask: Mask leftmost 8 pixels
 0x2                    @@mask_top      EQU     00000000000010b     ; Edge mask: Mask topmost 8 pixels

			;;--------------------------------------------------------------------------;;
			;; Useful bits for Color Stack Mode                                         ;;
			;;                                                                          ;;
			;; Display format word layout in Color Stack Mode:                          ;;
			;;   13   12    11   10    9    8    7    6    5    4    3    2    1    0   ;;
			;; +----+-----+----+----+----+----+----+----+----+----+----+----+----+----+ ;;
			;; |Adv.|FG   |GRAM|           GRAM/GROM Card #            |   FG Color   | ;;
			;; |col |Bit3/|GROM|    (0-255 for GROM, 0-63 for GRAM)    |   Bits 0-2   | ;;
			;; |stck|----------|                                       |              | ;;
			;; |    |col. sqr. |                                       |              | ;;
			;; |    |mode slct.|                                       |              | ;;
			;; +----+-----+----+----+----+----+----+----+----+----+----+----+----+----+ ;;
			;;                                                                          ;;
			;; Color Stack Notes:                                                       ;;
			;;  -- If GRAM card, two MSBs of Card # are ignored, and may be used by     ;;
			;;     the program to store other information.                              ;;
			;;                                                                          ;;
			;;  -- Bit 12 is set and Bit 11 is cleared, this word is treated as a       ;;
			;;     colored-square-mode display word, in the format below.               ;;
			;;                                                                          ;;
			;;  -- The color stack is reset to offset 0 at the start of the display.    ;;
			;;     Setting the 'advance' bit advances the color stack by one for that   ;;
			;;     card and all cards after it in normal left-to-right scanning order.  ;;
			;;                                                                          ;;
			;;  -- Bits 14 and 15 of the display format word are ignored and may be     ;;
			;;     used by the program to store status bits, etc.                       ;;
			;;                                                                          ;;
			;; Display format word layout in Colored Squares Mode:                      ;;
			;;                                                                          ;;
			;;   13   12   11   10    9    8    7    6    5    4    3    2    1    0    ;;
			;; +----+----+----+----+----+----+----+----+----+----+----+----+----+----+  ;;
			;; |Pix3|  1 |  0 | Pix. 3  | Pix. 2 color | Pix. 1 color | Pix. 0 color |  ;;
			;; |Bit2|    |    | bit 0-1 |    (0-7)     |    (0-7)     |    (0-7)     |  ;;
			;; +----+----+----+----+----+----+----+----+----+----+----+----+----+----+  ;;
			;;                                                                          ;;
			;; Pixels are display like so:  +-----+-----+                               ;;
			;;                              |Pixel|Pixel|                               ;;
			;;                              |  0  |  1  |                               ;;
			;;                              +-----+-----+                               ;;
			;;                              |Pixel|Pixel|                               ;;
			;;                              |  2  |  3  |                               ;;
			;;                              +-----+-----+                               ;;
			;;                                                                          ;;
			;; Colored Square Mode Notes:                                               ;;
			;;                                                                          ;;
			;;  -- It is not possible to advance the color stack with a card that is    ;;
			;;     displayed in color-stack mode.                                       ;;
			;;                                                                          ;;
			;;  -- Color 7 in colored squares mode instead shows the current color on   ;;
			;;     the color stack.                                                     ;;
			;;                                                                          ;;
			;;  -- Colors 0 through 6 in a colored-square card will interact with       ;;
			;;     MOBs, but color 7 will not.                                          ;;
			;;                                                                          ;;
			;;  -- Bits 14 and 15 of the display format word are ignored and may be     ;;
			;;     used by the program to store status bits, etc.                       ;;
			;;--------------------------------------------------------------------------;;
 0x0                    @@cs_fg0        EQU     00000000000000b     ; foreground ==  0
 0x1                    @@cs_fg1        EQU     00000000000001b     ; foreground ==  1
 0x2                    @@cs_fg2        EQU     00000000000010b     ; foreground ==  2
 0x3                    @@cs_fg3        EQU     00000000000011b     ; foreground ==  3
 0x4                    @@cs_fg4        EQU     00000000000100b     ; foreground ==  4
 0x5                    @@cs_fg5        EQU     00000000000101b     ; foreground ==  5
 0x6                    @@cs_fg6        EQU     00000000000110b     ; foreground ==  6
 0x7                    @@cs_fg7        EQU     00000000000111b     ; foreground ==  7
 0x1000                 @@cs_fg8        EQU     01000000000000b     ; foreground ==  8
 0x1001                 @@cs_fg9        EQU     01000000000001b     ; foreground ==  9
 0x1002                 @@cs_fgA        EQU     01000000000010b     ; foreground == 10
 0x1003                 @@cs_fgB        EQU     01000000000011b     ; foreground == 11
 0x1004                 @@cs_fgC        EQU     01000000000100b     ; foreground == 12
 0x1005                 @@cs_fgD        EQU     01000000000101b     ; foreground == 13
 0x1006                 @@cs_fgE        EQU     01000000000110b     ; foreground == 14
 0x1007                 @@cs_fgF        EQU     01000000000111b     ; foreground == 15
 0x7f8                  @@cs_card       EQU     00011111111000b     ; Card # mask (GRAM/GROM index #)
 0x800                  @@cs_gram       EQU     00100000000000b     ; Selects cards from GRAM if set
 0x2000                 @@cs_advance    EQU     10000000000000b     ; Advances color stack.
 0x1000                 @@cs_colsqr     EQU     01000000000000b     ; Selects 'colored square mode'

 0x7                    @@cs_pix0       EQU     00000000000111b     ; ColSqr Pixel 0 mask
 0x38                   @@cs_pix1       EQU     00000000111000b     ; ColSqr Pixel 1 mask
 0x1c0                  @@cs_pix2       EQU     00000111000000b     ; ColSqr Pixel 2 mask
 0x2600                 @@cs_pix3       EQU     10011000000000b     ; ColSqr Pixel 3 mask

 0x0                    @@cs_pix0_0     EQU     00000000000000b     ; ColSqr Pixel 0, color == 0
 0x1                    @@cs_pix0_1     EQU     00000000000001b     ; ColSqr Pixel 0, color == 1
 0x2                    @@cs_pix0_2     EQU     00000000000010b     ; ColSqr Pixel 0, color == 2
 0x3                    @@cs_pix0_3     EQU     00000000000011b     ; ColSqr Pixel 0, color == 3
 0x4                    @@cs_pix0_4     EQU     00000000000100b     ; ColSqr Pixel 0, color == 4
 0x5                    @@cs_pix0_5     EQU     00000000000101b     ; ColSqr Pixel 0, color == 5
 0x6                    @@cs_pix0_6     EQU     00000000000110b     ; ColSqr Pixel 0, color == 6
 0x7                    @@cs_pix0_7     EQU     00000000000111b     ; ColSqr Pixel 0, color == 7

 0x0                    @@cs_pix1_0     EQU     00000000000000b     ; ColSqr Pixel 1, color == 0
 0x8                    @@cs_pix1_1     EQU     00000000001000b     ; ColSqr Pixel 1, color == 1
 0x10                   @@cs_pix1_2     EQU     00000000010000b     ; ColSqr Pixel 1, color == 2
 0x18                   @@cs_pix1_3     EQU     00000000011000b     ; ColSqr Pixel 1, color == 3
 0x20                   @@cs_pix1_4     EQU     00000000100000b     ; ColSqr Pixel 1, color == 4
 0x28                   @@cs_pix1_5     EQU     00000000101000b     ; ColSqr Pixel 1, color == 5
 0x30                   @@cs_pix1_6     EQU     00000000110000b     ; ColSqr Pixel 1, color == 6
 0x38                   @@cs_pix1_7     EQU     00000000111000b     ; ColSqr Pixel 1, color == 7

 0x0                    @@cs_pix2_0     EQU     00000000000000b     ; ColSqr Pixel 2, color == 0
 0x40                   @@cs_pix2_1     EQU     00000001000000b     ; ColSqr Pixel 2, color == 1
 0x80                   @@cs_pix2_2     EQU     00000010000000b     ; ColSqr Pixel 2, color == 2
 0xc0                   @@cs_pix2_3     EQU     00000011000000b     ; ColSqr Pixel 2, color == 3
 0x100                  @@cs_pix2_4     EQU     00000100000000b     ; ColSqr Pixel 2, color == 4
 0x140                  @@cs_pix2_5     EQU     00000101000000b     ; ColSqr Pixel 2, color == 5
 0x180                  @@cs_pix2_6     EQU     00000110000000b     ; ColSqr Pixel 2, color == 6
 0x1c0                  @@cs_pix2_7     EQU     00000111000000b     ; ColSqr Pixel 2, color == 7

 0x0                    @@cs_pix3_0     EQU     00000000000000b     ; ColSqr Pixel 3, color == 0
 0x200                  @@cs_pix3_1     EQU     00001000000000b     ; ColSqr Pixel 3, color == 1
 0x400                  @@cs_pix3_2     EQU     00010000000000b     ; ColSqr Pixel 3, color == 2
 0x600                  @@cs_pix3_3     EQU     00011000000000b     ; ColSqr Pixel 3, color == 3
 0x2000                 @@cs_pix3_4     EQU     10000000000000b     ; ColSqr Pixel 3, color == 4
 0x2200                 @@cs_pix3_5     EQU     10001000000000b     ; ColSqr Pixel 3, color == 5
 0x2400                 @@cs_pix3_6     EQU     10010000000000b     ; ColSqr Pixel 3, color == 6
 0x2600                 @@cs_pix3_7     EQU     10011000000000b     ; ColSqr Pixel 3, color == 7

			;;--------------------------------------------------------------------------;;
			;; Useful bits for Foreground/Background Mode                               ;;
			;;                                                                          ;;
			;; Display format word layout in Color Stack Mode:                          ;;
			;;   13   12   11   10    9    8    7    6    5    4    3    2    1    0    ;;
			;; +----+----+----+----+----+----+----+----+----+----+----+----+----+----+  ;;
			;; |BG  |BG  |GRAM|BG  |BG  |      GRAM/GROM Card #       |   FG Color   |  ;;
			;; |Bit2|Bit3|GROM|Bit1|Bit0|          (0 - 63)           |   Bits 0-2   |  ;;
			;; +----+----+----+----+----+----+----+----+----+----+----+----+----+----+  ;;
			;;--------------------------------------------------------------------------;;

 0x0                    @@fb_fg0        EQU     00000000000000b     ; foreground ==  0
 0x1                    @@fb_fg1        EQU     00000000000001b     ; foreground ==  1
 0x2                    @@fb_fg2        EQU     00000000000010b     ; foreground ==  2
 0x3                    @@fb_fg3        EQU     00000000000011b     ; foreground ==  3
 0x4                    @@fb_fg4        EQU     00000000000100b     ; foreground ==  4
 0x5                    @@fb_fg5        EQU     00000000000101b     ; foreground ==  5
 0x6                    @@fb_fg6        EQU     00000000000110b     ; foreground ==  6
 0x7                    @@fb_fg7        EQU     00000000000111b     ; foreground ==  7

 0x0                    @@fb_bg0        EQU     00000000000000b     ; background ==  0
 0x200                  @@fb_bg1        EQU     00001000000000b     ; background ==  1
 0x400                  @@fb_bg2        EQU     00010000000000b     ; background ==  2
 0x600                  @@fb_bg3        EQU     00011000000000b     ; background ==  3
 0x2000                 @@fb_bg4        EQU     10000000000000b     ; background ==  4
 0x2200                 @@fb_bg5        EQU     10001000000000b     ; background ==  5
 0x2400                 @@fb_bg6        EQU     10010000000000b     ; background ==  6
 0x2600                 @@fb_bg7        EQU     10011000000000b     ; background ==  7
 0x1000                 @@fb_bg8        EQU     01000000000000b     ; background ==  8
 0x1200                 @@fb_bg9        EQU     01001000000000b     ; background ==  9
 0x1400                 @@fb_bgA        EQU     01010000000000b     ; background == 10
 0x1600                 @@fb_bgB        EQU     01011000000000b     ; background == 11
 0x3000                 @@fb_bgC        EQU     11000000000000b     ; background == 12
 0x3200                 @@fb_bgD        EQU     11001000000000b     ; background == 13
 0x3400                 @@fb_bgE        EQU     11010000000000b     ; background == 14
 0x3600                 @@fb_bgF        EQU     11011000000000b     ; background == 15

 0x1f8                  @@fb_card       EQU     00000111111000b     ; Card # mask (GRAM/GROM index #)
 0x800                  @@fb_gram       EQU     00100000000000b     ; Selects cards from GRAM if set

			                ENDS

			;;==========================================================================;;
			;;  STIC COLOR-NAMES                                                        ;;
			;;                                                                          ;;
			;;  These are easier to remember short mnemonics for the STIC's colors.     ;;
			;;  You can use the C_xxx colors for color-stack registers, border colors   ;;
			;;  and so on where the color is stored in a contiguous field.  Use the     ;;
			;;  X_xxx color names for the foreground color on display cards in color-   ;;
			;;  stack mode, or for MOB attribute words.                                 ;;
			;;                                                                          ;;
			;;  Note that for the primary color set, C_xxx and X_xxx are identical.     ;;
			;;==========================================================================;;

 0x0                    C_BLK   EQU     $0              ; Black
 0x1                    C_BLU   EQU     $1              ; Blue
 0x2                    C_RED   EQU     $2              ; Red
 0x3                    C_TAN   EQU     $3              ; Tan
 0x4                    C_DGR   EQU     $4              ; Dark Green
 0x5                    C_GRN   EQU     $5              ; Green
 0x6                    C_YEL   EQU     $6              ; Yellow
 0x7                    C_WHT   EQU     $7              ; White
 0x8                    C_GRY   EQU     $8              ; Grey
 0x9                    C_CYN   EQU     $9              ; Cyan
 0xa                    C_ORG   EQU     $A              ; Orange
 0xb                    C_BRN   EQU     $B              ; Brown
 0xc                    C_PNK   EQU     $C              ; Pink
 0xd                    C_LBL   EQU     $D              ; Light Blue
 0xe                    C_YGR   EQU     $E              ; Yellow-Green
 0xf                    C_PUR   EQU     $F              ; Purple

 0x0                    X_BLK   EQU     $0              ; Black
 0x1                    X_BLU   EQU     $1              ; Blue
 0x2                    X_RED   EQU     $2              ; Red
 0x3                    X_TAN   EQU     $3              ; Tan
 0x4                    X_DGR   EQU     $4              ; Dark Green
 0x5                    X_GRN   EQU     $5              ; Green
 0x6                    X_YEL   EQU     $6              ; Yellow
 0x7                    X_WHT   EQU     $7              ; White
 0x1000                 X_GRY   EQU     $1000           ; Grey
 0x1001                 X_CYN   EQU     $1001           ; Cyan
 0x1002                 X_ORG   EQU     $1002           ; Orange
 0x1003                 X_BRN   EQU     $1003           ; Brown
 0x1004                 X_PNK   EQU     $1004           ; Pink
 0x1005                 X_LBL   EQU     $1005           ; Light Blue
 0x1006                 X_YGR   EQU     $1006           ; Yellow-Green
 0x1007                 X_PUR   EQU     $1007           ; Purple


			            INCLUDE "macro/util.mac"
			;; ======================================================================== ;;
			;;  UTIL.MAC                                            Default Macro Set   ;;
			;;  General utility macros.                                                 ;;
			;;  Joseph Zbiciak <im14u2c@globalcrossing.net>                             ;;
			;;  These macros are hereby released into the Public Domain.                ;;
			;;                                                                          ;;
			;;  Macros defined in this file:                                            ;;
			;;                                                                          ;;
			;;      SETISR  a, r       Sets ISR vector to point to 'a'. 'r' is a temp.  ;;
			;;      MVOD    r, a       Writes 'r' as double-byte-data to 'a'.           ;;
			;;      MVOD@   r, p       Writes 'r' as double-byte-date via 'p'.          ;;
			;;      COPY    s, t, d    Copies address 's' to address 'd' via 't'.       ;;
			;;      COPY@   s, t, d    Copies from ptr 's' to ptr 'd' via 't'.          ;;
			;;      CALLD   label      Calls 'label' and disables interrupts.           ;;
			;;      LOOP    r, l       Decrements 'r' and loops to 'l' if non-zero.     ;;
			;;      LOOPPL  r, l       Decrements 'r' and loops to 'l' if non-negative. ;;
			;;      SWITCH  r, tbl     Implements switch-case via branch lookup table.  ;;
			;;      SWITCHB r          Implements switch-case via series of branches.   ;;
			;;      SPINEQ  a, r       Loop while value at address is equal to 'r'      ;;
			;;      SPINEQ@ p, r       Loop while value at address is equal to 'r'      ;;
			;;      SPINNE  a, r       Loop while value at address is not equal to 'r'  ;;
			;;      SPINNE@ p, r       Loop while value at address is not equal to 'r'  ;;
			;;      SLRC    r, n       Shift Logically Right into Carry/Overflow        ;;
			;;      DSLLC   h, l, n    32-bit Shift Logically Left into Carry/Overflow  ;;
			;;      DSLRC   h, l, n    32-bit Shift Logically Right into Carry/Overflow ;;
			;;      DSARC   h, l, n    32-bit Shift Arithmetically Right into Carry/Ov. ;;
			;;      SLLn    r, n       Shift Logically Left                             ;;
			;;      SLLCn   r, n       Shift Logically Left into Carry/Overflow         ;;
			;;      SLRn    r, n       Shift Logically Right                            ;;
			;;      SARn    r, n       Shift Arithmetically Right                       ;;
			;;      SLRCn   r, n       Shift Logically Right into Carry/Overflow        ;;
			;;      SARCn   r, n       Shift Arithmetically Right into Carry/Overflow   ;;
			;;      DSLLCn  h, l, n    32-bit Shift Logically Left into Carry/Overflow  ;;
			;;      DSLRCn  h, l, n    32-bit Shift Logically Right into Carry/Overflow ;;
			;;      DSARCn  h, l, n    32-bit Shift Arithmetically Right into Carry/Ov. ;;
			;;      DADDR h0,l0,h1,l1  Add 32-bit value in h0:l0 to value in h1:l1      ;;
			;;      DSUBR h0,l0,h1,l1  Subtract 32-bit value in h0:l0 from h1:l1        ;;
			;;      XCHG    a, b       Exchange contents of reg 'a' with reg 'b'        ;;
			;;      ORR     a, b       Bitwise OR register 'a' into register 'b'        ;;
			;;      ORI     a, b       Bitwise OR constant 'a' into register 'b'        ;;
			;;      OR@     a, b       Bitwise OR value at ptr 'a' into register 'b'    ;;
			;;      ORD     a, b       Bitwise OR value at addr 'a' into register 'b'   ;;
			;;      XTND8   r          Sign-extend 'r' from 8 to 16 bits.               ;;
			;;      UNPKL   r, l       Unpack 8-bit values to lower byte of two regs.   ;;
			;;      UNPKH   r, l       Unpack 8-bit values to upper byte of two regs.   ;;
			;;                                                                          ;;
			;; ======================================================================== ;;

			    IF (DEFINED _UTIL_MAC) = 0

 0x1                    _UTIL_MAC EQU 1

			;; ======================================================================== ;;
			;;  SETISR a, r                                                             ;;
			;;  Sets ISR vector to point to address 'a'.  Trashes 'r'.                  ;;
			;;                                                                          ;;
			;;  ARGUMENTS                                                               ;;
			;;      a   Address of ISR                                                  ;;
			;;      r   Register to use as a temporary (R0 thru R3)                     ;;
			;; ======================================================================== ;;
			MACRO   SETISR  a, r
			        MVII    #%a%, %r%
			        MVOD    %r%, $100
			ENDM

			;; ======================================================================== ;;
			;;  MVOD r, a                                                               ;;
			;;  Write a 16-bit value as Double-Byte-Data.  Leaves its first operand     ;;
			;;  byte-swapped.                                                           ;;
			;;                                                                          ;;
			;;  ARGUMENTS                                                               ;;
			;;      r   Register to write.  Must be one of R0, R1, R2, R3               ;;
			;;      a   Address to write to.  Macro will write to Addr and Addr + 1.    ;;
			;; ======================================================================== ;;
			MACRO   MVOD    r,  a
			        MVO     %r%,    %a%
			        SWAP    %r%
			        MVO     %r%,    %a% + 1
			ENDM

			;; ======================================================================== ;;
			;;  MVOD@ r, p                                                              ;;
			;;  Write a 16-bit value as Double-Byte-Data.  Leaves its first operand     ;;
			;;  byte-swapped.  If 'p' is R4, R5, or R6, it is left pointing after the   ;;
			;;  written data.  If 'p' is R1, R2, or R3, it is left pointing at the      ;;
			;;  same location.                                                          ;;
			;;                                                                          ;;
			;;  ARGUMENTS                                                               ;;
			;;      r   Register to write.  Must be one of R0, R1, R2, R3               ;;
			;;      p   Register containing address to write to.  Must be one of R1     ;;
			;;          through R6.                                                     ;;
			;; ======================================================================== ;;
			MACRO   MVOD@   r,  p
			        MVO@    %r%,    %p%
			        SWAP    %r%
			        MVO@    %r%,    %p%
			ENDM


			;; ======================================================================== ;;
			;;  COPY  s, t, d                                                           ;;
			;;  Copies a value from the source address 's' to the destination address   ;;
			;;  'd', holding the copy in temporary register 't'.                        ;;
			;;                                                                          ;;
			;;  ARGUMENTS                                                               ;;
			;;      s   Source address (R1 thru R6)                                     ;;
			;;      t   Temporary register (R0 thru R6)                                 ;;
			;;      d   Destination address (R1 thru R6)                                ;;
			;; ======================================================================== ;;
			MACRO   COPY    s, t, d
			        MVI     %s%, %t%
			        MVO     %t%, %d%
			ENDM

			;; ======================================================================== ;;
			;;  COPY@ s, t, d                                                           ;;
			;;  Copies a value from the source pointer 's' to the destination pointer   ;;
			;;  'd', holding the copy in temporary register 't'.                        ;;
			;;                                                                          ;;
			;;  ARGUMENTS                                                               ;;
			;;      s   Source pointer (R1 thru R6)                                     ;;
			;;      t   Temporary register (R0 thru R6)                                 ;;
			;;      d   Destination pointer (R1 thru R6)                                ;;
			;; ======================================================================== ;;
			MACRO   COPY@   s, t, d
			        MVI@    %s%, %t%
			        MVO@        %t%, %d%
			ENDM

			;; ======================================================================== ;;
			;;  CALLD   label                                                           ;;
			;;  Call and disable interrupts.  Return address goes to R5.                ;;
			;; ======================================================================== ;;
			MACRO   CALLD   label
			        JSRD    R5, %label%
			ENDM

			;; ======================================================================== ;;
			;;  LOOP r, l                                                               ;;
			;;  Implements a simple looping construct.  Decrements 'r', and branches    ;;
			;;  to the label 'l' if it's non-zero.                                      ;;
			;;                                                                          ;;
			;;  ARGUMENTS                                                               ;;
			;;      r   Register to decrement.                                          ;;
			;;      l   Label to jump to if register is non-zero.                       ;;
			;;                                                                          ;;
			;;  EXAMPLE                                                                 ;;
			;;      MVII    #10,    R0                                                  ;;
			;;  @@l MVO@    R1,     R4      ;\__ This iterates 10 times.                ;;
			;;      LOOP    R0,     @@l     ;/                                          ;;
			;; ======================================================================== ;;
			MACRO   LOOP    r, l
			        DECR    %r%
			        BNEQ    %l%
			ENDM

			;; ======================================================================== ;;
			;;  LOOPPL r, l                                                             ;;
			;;  Implements a simple looping construct.  Decrements 'r', and branches    ;;
			;;  to the label 'l' if it's non-negative.                                  ;;
			;;                                                                          ;;
			;;  ARGUMENTS                                                               ;;
			;;      r   Register to decrement.                                          ;;
			;;      l   Label to jump to if register is non-zero.                       ;;
			;;                                                                          ;;
			;;  EXAMPLE                                                                 ;;
			;;      MVII    #10,    R0                                                  ;;
			;;  @@l MVO@    R1,     R4      ;\__ This iterates 11 times.                ;;
			;;      LOOPPL  R0,     @@l     ;/                                          ;;
			;; ======================================================================== ;;
			MACRO   LOOPPL  r, l
			        DECR    %r%
			        BPL     %l%
			ENDM

			;; ======================================================================== ;;
			;;  SWITCH r, tbl                                                           ;;
			;;  Implements a simple "jump table".  The argument 'tbl' points to an      ;;
			;;  array of labels representing the 'cases' of the SWITCH.  The register   ;;
			;;  provided by the user will be left pointing into the jump table.  If     ;;
			;;  the register is auto-incrementing, it will point *after* the entry      ;;
			;;  used, otherwise it will point at the entry used.                        ;;
			;;                                                                          ;;
			;;  The switch table can appear immediately after SWITCH, or it can         ;;
			;;  appear elsewhere in the program.  This SWITCH macro only works with     ;;
			;;  16-bit ROM widths.                                                      ;;
			;;                                                                          ;;
			;;  ARGUMENTS                                                               ;;
			;;      r   Value to "switch" on.  Must be a register R1 thru R5.  Value    ;;
			;;          in the register must be in range 0...n.                         ;;
			;;                                                                          ;;
			;;  EXAMPLE                                                                 ;;
			;;      SWITCH  R0, @@swtbl                                                 ;;
			;;  @@swtbl:                                                                ;;
			;;      DECLE   @@case_0, @@case_1, @@case_2, @@case_3                      ;;
			;;                                                                          ;;
			;;  @@case_0:                                                               ;;
			;;      ;....                                                               ;;
			;;                                                                          ;;
			;;  @@case_1:                                                               ;;
			;;      ;....                                                               ;;
			;;                                                                          ;;
			;;  @@case_2:                                                               ;;
			;;      ;....                                                               ;;
			;;                                                                          ;;
			;;  @@case_3:                                                               ;;
			;;      ;....                                                               ;;
			;;                                                                          ;;
			;; ======================================================================== ;;
			MACRO   SWITCH  r,  tbl
			        ADDI    #%tbl%, %r%
			        MVI@    %r%, PC
			ENDM


			;; ======================================================================== ;;
			;;  SWITCHB r                                                               ;;
			;;  Implements a simple "jump table".  User must follow "SWITCH" with a     ;;
			;;  series of "B @@label" for each of the cases.  The register supplied to  ;;
			;;  the switch will be left doubled.                                        ;;
			;;                                                                          ;;
			;;  This form of switch statement requires the branch instructions to       ;;
			;;  immediately follow the SWITCHB.  This version may be more useful if     ;;
			;;  retaining the value of 'r' is required.                                 ;;
			;;                                                                          ;;
			;;  ARGUMENTS                                                               ;;
			;;      r   Value to "switch" on.  Must be in range 0...n.  Value will be   ;;
			;;          doubled after this macro.                                       ;;
			;;                                                                          ;;
			;;  EXAMPLE                                                                 ;;
			;;      SWITCHB R0                                                          ;;
			;;      B       @@case_0                                                    ;;
			;;      B       @@case_1                                                    ;;
			;;      B       @@case_2                                                    ;;
			;;      B       @@case_3                                                    ;;
			;; ======================================================================== ;;
			MACRO   SWITCHB r
			        ADDR    %r%, %r%
			        ADDR    %r%, PC
			ENDM

			;; ======================================================================== ;;
			;;  SPINEQ a, r                                                             ;;
			;;  Loop while value at 'a' equals value held in 'r'.  Can be useful for    ;;
			;;  synchronizing with ISRs.                                                ;;
			;;                                                                          ;;
			;;  ARGUMENTS                                                               ;;
			;;      a   Address to spin on.                                             ;;
			;;      r   Value to look for.                                              ;;
			;;                                                                          ;;
			;;  EXAMPLE                                                                 ;;
			;;      CLRR    R0                                                          ;;
			;;      MVO     R0,     FLAG    ; Clear flag                                ;;
			;;      SPINEQ  FLAG,   R0      ; Wait until ISR sets flag.                 ;;
			;; ======================================================================== ;;
			MACRO   SPINEQ  a, r
			        CMP     %a%, %r%  ; 2 words
			        BEQ     $ - 2     ; $ avoids label.  ;-)
			ENDM

			;; ======================================================================== ;;
			;;  SPINEQ@ p, r                                                            ;;
			;;  Loop while value pointed to by 'a' equals value held in 'r'.  Can be    ;;
			;;  useful for synchronizing with ISRs.                                     ;;
			;;                                                                          ;;
			;;  NOTE:  'p' should be a non-incrementing pointer!  If an incrementing    ;;
			;;  pointer is used, then this becomes a sort of "string search" instead.   ;;
			;;                                                                          ;;
			;;  ARGUMENTS                                                               ;;
			;;      p   Address to spin on.                                             ;;
			;;      r   Value to look for.                                              ;;
			;;                                                                          ;;
			;;  EXAMPLE                                                                 ;;
			;;      CLRR    R0                                                          ;;
			;;      MVO@    R0,     R3      ; Clear flag                                ;;
			;;      SPINEQ@ R3,     R0      ; Wait until ISR sets flag.                 ;;
			;; ======================================================================== ;;
			MACRO   SPINEQ@ a, r
			        CMP@    %a%, %r%  ; 1 words
			        BEQ     $ - 1     ; $ avoids label.  ;-)
			ENDM

			;; ======================================================================== ;;
			;;  SPINNE a, r                                                             ;;
			;;  Loop while value at 'a' does not equal value held in 'r'.               ;;
			;;  Can be useful for synchronizing with ISRs.                              ;;
			;;                                                                          ;;
			;;  ARGUMENTS                                                               ;;
			;;      a   Address to spin on.                                             ;;
			;;      r   Value to look for.                                              ;;
			;;                                                                          ;;
			;;  EXAMPLE                                                                 ;;
			;;      MVII    #3,     R0                                                  ;;
			;;      MVO@    R0,     CNT     ; Wait 3 frames                             ;;
			;;      CLRR    R0                                                          ;;
			;;      SPINNE  CNT,    R0      ; Wait until ISR's counter expires          ;;
			;; ======================================================================== ;;
			MACRO   SPINNE  a, r
			        CMP     %a%, %r%  ; 2 words
			        BNEQ    $ - 2     ; $ avoids label.  ;-)
			ENDM

			;; ======================================================================== ;;
			;;  SPINEQ@ p, r                                                            ;;
			;;  Loop while value pointed to by 'a' does not equal value held in 'r'.    ;;
			;;  Can be useful for synchronizing with ISRs.                              ;;
			;;                                                                          ;;
			;;  NOTE:  'p' should be a non-incrementing pointer!  If an incrementing    ;;
			;;  pointer is used, then this becomes a sort of "string search" instead.   ;;
			;;                                                                          ;;
			;;  ARGUMENTS                                                               ;;
			;;      p   Address to spin on.                                             ;;
			;;      r   Value to look for.                                              ;;
			;;                                                                          ;;
			;;  EXAMPLE                                                                 ;;
			;;      MVII    #3,     R0                                                  ;;
			;;      MVO@    R0,     R3      ; Wait 3 frames                             ;;
			;;      CLRR    R0                                                          ;;
			;;      SPINNE@ R3,     R0      ; Wait until ISR's counter expires          ;;
			;; ======================================================================== ;;
			MACRO   SPINNE@ a, r
			        CMP@    %a%, %r%  ; 1 words
			        BNEQ    $ - 1     ; $ avoids label.  ;-)
			ENDM


			;; ======================================================================== ;;
			;;  SHIFT MACROS                                                            ;;
			;;  The following set of macros implement "extended shifts", extending the  ;;
			;;  shift amount of the existing CP-1600 shift instructions.                ;;
			;;                                                                          ;;
			;;  WARNING:  These shift sequences are non-interruptible, so be careful.   ;;
			;;  Shift amounts larger than 8, and double-precision shift amounts larger  ;;
			;;  than 4 can potentially affect video display in a negative way.          ;;
			;;                                                                          ;;
			;;  The following shift macros are provided:                                ;;
			;;                                                                          ;;
			;;      SLRC   h, l, n  ; Shift logically right into Carry/Overflow         ;;
			;;      DSLLC  h, l, n  ; 32-bit Shift Logically Left into Carry/Overflow   ;;
			;;      DSLRC  h, l, n  ; 32-bit Shift Logically Right into Carry/Overflow  ;;
			;;      DSARC  h, l, n  ; 32-bit Shift Arithmetically Right into Carry/Ov.  ;;
			;;      SLLn   r, n     ; Shift Logically Left                              ;;
			;;      SLLCn  r, n     ; Shift Logically Left into Carry/Overflow          ;;
			;;      SLRn   r, n     ; Shift Logically Right                             ;;
			;;      SARn   r, n     ; Shift Arithmetically Right                        ;;
			;;      SLRCn  r, n     ; Shift Logically Right into Carry/Overflow         ;;
			;;      SARCn  r, n     ; Shift Arithmetically Right into Carry/Overflow    ;;
			;;      DSLLCn h, l, n  ; 32-bit Shift Logically Left into Carry/Overflow   ;;
			;;      DSLRCn h, l, n  ; 32-bit Shift Logically Right into Carry/Overflow  ;;
			;;      DSARCn h, l, n  ; 32-bit Shift Arithmetically Right into Carry/Ov.  ;;
			;;                                                                          ;;
			;;  The Dxxxx macros implement a double-precision (32-bit) shift across     ;;
			;;  two registers.  The variants lacking the 'n' suffix only support        ;;
			;;  shift amounts of 1 or 2.                                                ;;
			;;                                                                          ;;
			;;  For each of the above, the final shift in the expanded series is        ;;
			;;  always a shift-by-2, except of course in the case where the user        ;;
			;;  specifies a shift of exactly 1.                                         ;;
			;; ======================================================================== ;;


			;; ======================================================================== ;;
			;;  SLRC r, n                                                               ;;
			;;  Shift logical right into carry/overflow.                                ;;
			;;                                                                          ;;
			;;  ARGUMENTS                                                               ;;
			;;      r   Register to shift right.                                        ;;
			;;      n   Shift amount.  Must be a constant expression that evaluates to  ;;
			;;          1 or 2.                                                         ;;
			;; ======================================================================== ;;
			MACRO   SLRC r, n  
			        LISTING "code"
			    IF ((%n%) < 1) OR ((%n%) > 2)
			        ERR  "SLRC shift amount out of range!"
			    ENDI
			    IF (%n%) = 1
			        CLRC
			        RRC  %r%, 1
			    ENDI
			    IF (%n%) = 2
			        SARC %r%, %n%
			        ANDI #$3FFF, %r%
			    ENDI
			        LISTING "prev"
			ENDM

			;; ======================================================================== ;;
			;;  DSLLC, DSARC, DSLRC                                                     ;;
			;;  Double-precision shift macros.  These macros combine a shift with a     ;;
			;;  rotate in order to shift a 32-bit value across two registers.           ;;
			;;                                                                          ;;
			;;  ARGUMENTS                                                               ;;
			;;      h   Upper register of register pair to shift (R0 through R3)        ;;
			;;      l   Lower register of register pair to shift (R0 through R3)        ;;
			;;      n   Shift amount.  Must be a constant expression that evaluates to  ;;
			;;          1 or 2.                                                         ;;
			;; ======================================================================== ;;
			MACRO   DSLLC h, l, n  ;; double-precision shift logical left into carry/over
			        SLLC %l%, %n%  
			        RLC  %h%, %n%
			ENDM
			MACRO   DSARC h, l, n  ;; double-precision shift arith right into carry/over
			        SARC %h%, %n%
			        RRC  %l%, %n%
			ENDM
			MACRO   DSLRC h, l, n  ;; double-precision shift logical right into carry/over
			    LISTING "code"
			    IF ((%n%) < 1) OR ((%n%) > 2)
			        ERR  "DSLRC shift amount out of range!"
			    ENDI
			    IF (%n%) = 1
			        CLRC
			        RRC  %h%, 1
			        RRC  %l%, 1
			    ENDI
			    IF (%n%) = 2
			        SARC %h%, %n%
			        RRC  %l%, %n%
			        ANDI #$3FFF, %h%
			    ENDI
			    LISTING "prev"
			ENDM

			;; ======================================================================== ;;
			;;  __shft_n s, r, n                                                        ;;
			;;  Generic "shift expansion" macro set.  Expands shift amounts out to a    ;;
			;;  series of shifts by 1 or 2.  The macro uses a repeat block to generate  ;;
			;;  the series of shifts.                                                   ;;
			;; ======================================================================== ;;
			MACRO   __shft_n s, r, n
			    LISTING "code"
			    IF ((%n%) < 1)
			      ERR "Shift amount out of range.  Must be >= 1."
			    ELSE
			      IF ((%n%) AND 1) 
			        %s% %r%, 1
			      ENDI
			      RPT ((%n%) SHR 1)
			        %s% %r%, 2
			      ENDR
			    ENDI
			    LISTING "prev"
			ENDM

			;; ======================================================================== ;;
			;;  SLLn, SLLCn, SARn, SARCn, SLRn, SLRCn                                   ;;
			;;  Shift macros that expand the allowed constant range on the CP-1600's    ;;
			;;  shift instructions.  These rely on the generic macro above to expand    ;;
			;;  each macro out as a series of shifts.                                   ;;
			;;                                                                          ;;
			;;  ARGUMENTS                                                               ;;
			;;      r   Register to shift (R0 thru R3)                                  ;;
			;;      n   Shift amount.  Must be a constant expression >= 1               ;;
			;; ======================================================================== ;;
			MACRO   SLLn r, n
			        __shft_n SLL, %r%, %n%
			ENDM

			MACRO   SLLCn r, n
			        __shft_n SLLC, %r%, %n%
			ENDM

			MACRO   SARn r, n
			        __shft_n SAR, %r%, %n%
			ENDM

			MACRO   SARCn r, n
			        __shft_n SARC, %r%, %n%
			ENDM

			MACRO   SLRn r, n
			        __shft_n SLR, %r%, %n%
			ENDM

			MACRO   SLRCn r, n
			        LISTING "code"
			 IF ((%n%) < 3)
			        SLRC %r%, %n%
			 ELSE
			        __shft_n SLR, %r%, ((%n%) - 2)
			        SARC %r%, 2
			 ENDI
			        LISTING "prev"
			ENDM

			;; ======================================================================== ;;
			;;  DSLLCn, DSARCn, DSLRCn                                                  ;;
			;;  Shift macros that expand the allowed constant range on the double-      ;;
			;;  precision shift macros.  These rely on the generic macro above to       ;;
			;;  expand each macro out as a series of shifts, and on the Dxxxx shift     ;;
			;;  macros to provide the double-precision shifts.                          ;;
			;;                                                                          ;;
			;;  Notice how the 'h' and 'l' operands are grouped together as a single    ;;
			;;  operand when invoking __shft_n using the [] grouping operators.         ;;
			;;                                                                          ;;
			;;  ARGUMENTS                                                               ;;
			;;      h   Upper register of register pair to shift (R0 through R3)        ;;
			;;      l   Lower register of register pair to shift (R0 through R3)        ;;
			;;      n   Shift amount.  Must be a constant expression >= 1               ;;
			;; ======================================================================== ;;
			MACRO   DSLLCn h, l, n
			        __shft_n DSLLC, [%h%,%l%], %n%
			ENDM

			MACRO   DSARCn h, l, n
			        __shft_n DSARC, [%h%,%l%], %n%
			ENDM

			MACRO   DSLRCn h, l, n
			        __shft_n DSARC, [%h%,%l%], %n%
			        ANDI #($FFFF SHR %n%), %h%
			ENDM

			;; ======================================================================== ;;
			;;  DADDR h0,l0, h1,l1                                                      ;;
			;;  Adds register pair h0:l0 to register pair h1:l1 (32-bit ADDR).          ;;
			;; ======================================================================== ;;
			MACRO   DADDR h0,l0,h1,l1
			        ADDR  %l0%, %l1%  ; add lower halves
			        ADCR  %h1%        ; propogate carry into upper half
			        ADDR  %h0%, %h1%  ; add upper halves
			ENDM

			;; ======================================================================== ;;
			;;  DSUBR h0,l0, h1,l1                                                      ;;
			;;  Subtracts register pair h0:l0 from register pair h1:l1 (32-bit SUBR).   ;;
			;; ======================================================================== ;;
			MACRO   DSUBR h0,l0,h1,l1
			        SUBR  %l0%, %l1%  ; subtract lower halves
			        ADCR  %h1%        ; propogate borrow to upper half
			        DECR  %h1%        ; turn borrow into not-borrow
			        SUBR  %h0%, %h1%  ; subtract upper halves
			ENDM

			;; ======================================================================== ;;
			;;  XCHG a, b                                                               ;;
			;;  Exchanges two values in registers using three-XOR-swap.                 ;;
			;;                                                                          ;;
			;;  ARGUMENTS                                                               ;;
			;;      a   Register 1 to swap                                              ;;
			;;      b   Register 2 to swap                                              ;;
			;; ======================================================================== ;;
			MACRO   XCHG a, b
			        XORR %a%, %b%
			        XORR %b%, %a%
			        XORR %a%, %b%
			ENDM

			;; ======================================================================== ;;
			;;  ORR a, b  -- Register-mode OR                                           ;;
			;;  Bitwise-ORs register 'a' into register 'b'                              ;;
			;;                                                                          ;;
			;;  ARGUMENTS                                                               ;;
			;;      a   Register with value to "OR"                                     ;;
			;;      b   Register holding result                                         ;;
			;; ======================================================================== ;;
			MACRO   ORR a, b
			        COMR %a%
			        ANDR %a%, %b%
			        COMR %a%
			        XORR %a%, %b%
			ENDM
			       
			;; ======================================================================== ;;
			;;  ORI a, b  -- Immediate mode OR                                          ;;
			;;  Bitwise-ORs constant 'a' into register 'b'                              ;;
			;;                                                                          ;;
			;;  ARGUMENTS                                                               ;;
			;;      a   Value to "OR"                                                   ;;
			;;      b   Register holding result                                         ;;
			;; ======================================================================== ;;
			MACRO   ORI a, b
			        ANDI #($FFFF AND (NOT (%a%))), %b%
			        XORI #($FFFF AND      (%a%) ), %b%
			ENDM
			       
			;; ======================================================================== ;;
			;;  OR@ a, b   -- Indirect mode OR                                          ;;
			;;  Bitwise-ORs value pointed to by 'a' into register 'b'.  This macro      ;;
			;;  requires one word of stack space.                                       ;;
			;;                                                                          ;;
			;;  ARGUMENTS                                                               ;;
			;;      a   Address holding value to OR.                                    ;;
			;;      b   Register holding result.  (R0 thru R5)                          ;;
			;; ======================================================================== ;;
			MACRO   OR@ a, b
			        PSHR %b%
			        COMR %b%
			        AND@ %a%, %b%
			        XOR@ SP,  %b%
			ENDM
			       
			;; ======================================================================== ;;
			;;  ORD a, b   -- Direct mode OR                                            ;;
			;;  Bitwise-ORs value at address 'a' into register 'b'.  This macro         ;;
			;;  requires one word of stack space.                                       ;;
			;;                                                                          ;;
			;;  This macro is named "ORD" so as to not conflict with the assembler      ;;
			;;  keyword "OR".                                                           ;;
			;;                                                                          ;;
			;;  ARGUMENTS                                                               ;;
			;;      a   Address holding value to OR.                                    ;;
			;;      b   Register holding result.  (R0 thru R5)                          ;;
			;; ======================================================================== ;;
			MACRO   ORD  a, b
			        PSHR %b%
			        COMR %b%
			        AND  %a%, %b%
			        XOR@ SP,  %b%
			ENDM

			;; ======================================================================== ;;
			;;  XTND8 r                                                                 ;;
			;;  Sign-extend 8-bit value to 16 bits.  Assumes value has 0s in upper      ;;
			;;  half already.                                                           ;;
			;;                                                                          ;;
			;;  ARGUMENTS                                                               ;;
			;;      r   Register to extend from 8 to 16 bits                            ;;
			;; ======================================================================== ;;
			MACRO   XTND8 r
			        XORI    #$80, %r%
			        SUBI    #$80, %r%
			ENDM

			;; ======================================================================== ;;
			;;  UNPKL r, l                                                              ;;
			;;  Unpack 16-bit value in 'r' to two 8-bit values in 'r' and 'l'.          ;;
			;;  The unpacked values are left in the lower 8 bits of 'r' and 'l'.        ;;
			;;                                                                          ;;
			;;  ARGUMENTS                                                               ;;
			;;      r   Register to unpack.  When done, this will hold upper 8 bits.    ;;
			;;          Note: 'r' must be R0 through R3.                                ;;
			;;      l   Register to place lower 8 bits in.                              ;;
			;; ======================================================================== ;;
			MACRO   UNPKL r, l
			        MOVR    %r%, %l%
			        ANDI    #$FF, %l%
			        XORR    %l%, %r%
			        SWAP    %r%
			ENDM

			;; ======================================================================== ;;
			;;  UNPKH r, l                                                              ;;
			;;  Unpack 16-bit value in 'r' to two 8-bit values in 'r' and 'l'.          ;;
			;;  The unpacked values are left in the upper 8 bits of 'r' and 'l'.        ;;
			;;                                                                          ;;
			;;  ARGUMENTS                                                               ;;
			;;      r   Register to unpack.  When done, this will hold upper 8 bits.    ;;
			;;          Note: 'r' must be R0 through R3.                                ;;
			;;      l   Register to place lower 8 bits in.                              ;;
			;; ======================================================================== ;;
			MACRO   UNPK r, l
			        MOVR    %r%, %l%
			        ANDI    #$FF, %l%
			        XORR    %l%, %r%
			        SWAP    %l%
			ENDM

			    ENDI
			            INCLUDE "macro/stic.mac"
			;; ======================================================================== ;;
			;;  STIC.MAC                                            Default Macro Set   ;;
			;;  Joseph Zbiciak <im14u2c@globalcrossing.net>                             ;;
			;;  These macros are hereby released into the Public Domain.                ;;
			;; ======================================================================== ;;

			    IF (DEFINED _STIC_MAC) = 0

 0x1                    _STIC_MAC EQU 1

			;; ======================================================================== ;;
			;;  Note:  For each of the macros below that accepts a color name, the      ;;
			;;  following aliases are supported:                                        ;;
			;;                                                                          ;;
			;;          Black       BLK                 Grey (or Gray)  GRY             ;;
			;;          Blue        BLU                 Cyan            CYN             ;;
			;;          Red         RED                 Orange          ORG             ;;
			;;          Tan         TAN                 Brown           BRN             ;;
			;;          DarkGreen   DGR                 Pink            PNK             ;;
			;;          Green       GRN                 LightBlue       LBL             ;;
			;;          Yellow      YEL                 YellowGreen     YGR             ;;
			;;          White       WHT                 Purple          PUR             ;;
			;;                                                                          ;;
			;; ======================================================================== ;;

			;; ======================================================================== ;;
			;;  gen_cstk_card(c, g, fg, a)                                              ;;
			;;  Generate constant for a Color-Stack mode card.                          ;;
			;;                                                                          ;;
			;;  ARGUMENTS                                                               ;;
			;;      c   Card #, from 0 to 255 for GROM, 0 to 63 for GRAM.  When using   ;;
			;;          gen_cs_card() to generate a "format word", simply use Card #0.  ;;
			;;                                                                          ;;
			;;      g   Specify GROM to indicate card comes from GROM, or GRAM to       ;;
			;;          indicate card comes from GRAM.                                  ;;
			;;                                                                          ;;
			;;      fg  Foreground color, from the following set of names:              ;;
			;;                                                                          ;;
			;;              Black       DarkGreen       Grey (or Gray)  Pink            ;;
			;;              Blue        Green           Cyan            LightBlue       ;;
			;;              Red         Yellow          Orange          YellowGreen     ;;
			;;              Tan         White           Brown           Purple          ;;
			;;                                                                          ;;
			;;          NOTE: Foreground colors Grey through Purple are only available  ;;
			;;          on GRAM cards.  Attempts to use these colors on GROM cards      ;;
			;;          will result in (intentional) assembly errors.  This is a        ;;
			;;          limitation of the STIC itself.                                  ;;
			;;                                                                          ;;
			;;      a   Specifiy "Adv" or "Advance" to advance color stack.  Specify    ;;
			;;          "NoAdv" or "NoAdvance" to not advance color stack.              ;;
			;; ======================================================================== ;;
			MACRO gen_cstk_card(c, g, fg, a)
			        (%c%*8 + __CSTK.%g%_%fg% + __CSTK.%a%)
			ENDM

			;; ======================================================================== ;;
			;;  gen_csqr_card(p0, p1, p2, p3)                                           ;;
			;;  Generate constant for a Colored-Squares mode card                       ;;
			;;  Pixels are laid out like so:                                            ;;
			;;                              +-----+-----+                               ;;
			;;                              |Pixel|Pixel|                               ;;
			;;                              |  0  |  1  |                               ;;
			;;                              +-----+-----+                               ;;
			;;                              |Pixel|Pixel|                               ;;
			;;                              |  2  |  3  |                               ;;
			;;                              +-----+-----+                               ;;
			;;                                                                          ;;
			;;  ARGUMENTS                                                               ;;
			;;      p0  Color for Pixel 0 from set below.                               ;;
			;;      p1  Color for Pixel 1 from set below.                               ;;
			;;      p2  Color for Pixel 2 from set below.                               ;;
			;;      p3  Color for Pixel 3 from set below.                               ;;
			;;                                                                          ;;
			;;              Black       Red         DarkGreen       Yellow              ;;
			;;              Blue        Tan         Green           Stack               ;;
			;;                                                                          ;;
			;;          Note:  "Stack" refers to the color on the top of the color      ;;
			;;          stack.  It is not possible to advance the color stack from      ;;
			;;          colored-squares mode.  Use a color-stack card to do that.       ;;
			;; ======================================================================== ;;
			MACRO gen_csqr_card(p0,p1,p2,p3)
			        ($1000+__CSQR.p0_%p0%+__CSQR.p1_%p1%+__CSQR.p2_%p2%+__CSQR.p3_%p3%)
			ENDM

			;; ======================================================================== ;;
			;;  gen_fgbg_card(c, g, fg, bg)                                             ;;
			;;  Generate constant for a Foreground/Background mode                      ;;
			;;                                                                          ;;
			;;  ARGUMENTS                                                               ;;
			;;      c   Card #, from 0 to 255 for GROM, 0 to 63 for GRAM.  When using   ;;
			;;          gen_cs_card() to generate a "format word", simply use Card #0.  ;;
			;;                                                                          ;;
			;;      g   Specify GROM to indicate card comes from GROM, or GRAM to       ;;
			;;          indicate card comes from GRAM.                                  ;;
			;;                                                                          ;;
			;;      fg  Foreground color, from the following set of names:              ;;
			;;              Black       DarkGreen                                       ;;
			;;              Blue        Green                                           ;;
			;;              Red         Yellow                                          ;;
			;;              Tan         White                                           ;;
			;;                                                                          ;;
			;;      bg  Background color, from the following set of names:              ;;
			;;              Black       DarkGreen       Grey (or Gray)  Pink            ;;
			;;              Blue        Green           Cyan            LightBlue       ;;
			;;              Red         Yellow          Orange          YellowGreen     ;;
			;;              Tan         White           Brown           Purple          ;;
			;; ======================================================================== ;;
			MACRO gen_fgbg_card(c, g, fg, bg)
			        (%c%*8 + __FGBG.%g% + __FGBG.f_%fg% + __FGBG.b_%bg%)
			ENDM

			;; ======================================================================== ;;
			;;  __CSTK:  Constants used by the color-stack macros.                      ;;
			;; ======================================================================== ;;
 0x32a                  __CSTK          PROC
 0x0                    @@GROM_Black    EQU     00000000000000b     ; foreground ==  0  
 0x1                    @@GROM_Blue     EQU     00000000000001b     ; foreground ==  1
 0x2                    @@GROM_Red      EQU     00000000000010b     ; foreground ==  2
 0x3                    @@GROM_Tan      EQU     00000000000011b     ; foreground ==  3
 0x4                    @@GROM_DarkGreen    EQU 00000000000100b     ; foreground ==  4
 0x5                    @@GROM_Green    EQU     00000000000101b     ; foreground ==  5
 0x6                    @@GROM_Yellow   EQU     00000000000110b     ; foreground ==  6
 0x7                    @@GROM_White    EQU     00000000000111b     ; foreground ==  7

 0x800                  @@GRAM_Black    EQU     00100000000000b     ; foreground ==  0  
 0x801                  @@GRAM_Blue     EQU     00100000000001b     ; foreground ==  1
 0x802                  @@GRAM_Red      EQU     00100000000010b     ; foreground ==  2
 0x803                  @@GRAM_Tan      EQU     00100000000011b     ; foreground ==  3
 0x804                  @@GRAM_DarkGreen    EQU 00100000000100b     ; foreground ==  4
 0x805                  @@GRAM_Green    EQU     00100000000101b     ; foreground ==  5
 0x806                  @@GRAM_Yellow   EQU     00100000000110b     ; foreground ==  6
 0x807                  @@GRAM_White    EQU     00100000000111b     ; foreground ==  7
 0x1800                 @@GRAM_Grey     EQU     01100000000000b     ; foreground ==  8
 0x1800                 @@GRAM_Gray     EQU     01100000000000b     ; foreground ==  8
 0x1801                 @@GRAM_Cyan     EQU     01100000000001b     ; foreground ==  9
 0x1802                 @@GRAM_Orange   EQU     01100000000010b     ; foreground == 10
 0x1803                 @@GRAM_Brown    EQU     01100000000011b     ; foreground == 11
 0x1804                 @@GRAM_Pink     EQU     01100000000100b     ; foreground == 12
 0x1805                 @@GRAM_LightBlue    EQU 01100000000101b     ; foreground == 13
 0x1806                 @@GRAM_YellowGreen  EQU 01100000000110b     ; foreground == 14
 0x1807                 @@GRAM_Purple   EQU     01100000000111b     ; foreground == 15

 0x0                    @@GROM_BLK      EQU     00000000000000b     ; foreground ==  0  
 0x1                    @@GROM_BLU      EQU     00000000000001b     ; foreground ==  1
 0x2                    @@GROM_RED      EQU     00000000000010b     ; foreground ==  2
 0x3                    @@GROM_TAN      EQU     00000000000011b     ; foreground ==  3
 0x4                    @@GROM_DGR      EQU     00000000000100b     ; foreground ==  4
 0x5                    @@GROM_GRN      EQU     00000000000101b     ; foreground ==  5
 0x6                    @@GROM_YEL      EQU     00000000000110b     ; foreground ==  6
 0x7                    @@GROM_WHT      EQU     00000000000111b     ; foreground ==  7

 0x800                  @@GRAM_BLK      EQU     00100000000000b     ; foreground ==  0  
 0x801                  @@GRAM_BLU      EQU     00100000000001b     ; foreground ==  1
 0x802                  @@GRAM_RED      EQU     00100000000010b     ; foreground ==  2
 0x803                  @@GRAM_TAN      EQU     00100000000011b     ; foreground ==  3
 0x804                  @@GRAM_DGR      EQU     00100000000100b     ; foreground ==  4
 0x805                  @@GRAM_GRN      EQU     00100000000101b     ; foreground ==  5
 0x806                  @@GRAM_YEL      EQU     00100000000110b     ; foreground ==  6
 0x807                  @@GRAM_WHT      EQU     00100000000111b     ; foreground ==  7
 0x1800                 @@GRAM_GRY      EQU     01100000000000b     ; foreground ==  8
 0x1801                 @@GRAM_CYN      EQU     01100000000001b     ; foreground ==  9
 0x1802                 @@GRAM_ORG      EQU     01100000000010b     ; foreground == 10
 0x1803                 @@GRAM_BRN      EQU     01100000000011b     ; foreground == 11
 0x1804                 @@GRAM_PNK      EQU     01100000000100b     ; foreground == 12
 0x1805                 @@GRAM_LBL      EQU     01100000000101b     ; foreground == 13
 0x1806                 @@GRAM_YGR      EQU     01100000000110b     ; foreground == 14
 0x1807                 @@GRAM_PUR      EQU     01100000000111b     ; foreground == 15


 0x2000                 @@Adv           EQU     10000000000000b     ; Advances color stack.
 0x2000                 @@Advance       EQU     10000000000000b     ; Advances color stack.
 0x0                    @@NoAdv         EQU     00000000000000b     ; Does not advance color stack
 0x0                    @@NoAdvance     EQU     00000000000000b     ; Does not advance color stack
			                ENDP

			;; ======================================================================== ;;
			;;  __CSQR:  Constants used by the colored-squares macros.                  ;;
			;; ======================================================================== ;;
 0x32a                  __CSQR          PROC
 0x0                    @@p0_Black      EQU     00000000000000b 
 0x1                    @@p0_Blue       EQU     00000000000001b 
 0x2                    @@p0_Red        EQU     00000000000010b 
 0x3                    @@p0_Tan        EQU     00000000000011b 
 0x4                    @@p0_DarkGreen  EQU     00000000000100b 
 0x5                    @@p0_Green      EQU     00000000000101b 
 0x6                    @@p0_Yellow     EQU     00000000000110b 
 0x7                    @@p0_Stack      EQU     00000000000111b 

 0x0                    @@p1_Black      EQU     00000000000000b 
 0x8                    @@p1_Blue       EQU     00000000001000b 
 0x10                   @@p1_Red        EQU     00000000010000b 
 0x18                   @@p1_Tan        EQU     00000000011000b 
 0x20                   @@p1_DarkGreen  EQU     00000000100000b 
 0x28                   @@p1_Green      EQU     00000000101000b 
 0x30                   @@p1_Yellow     EQU     00000000110000b 
 0x38                   @@p1_Stack      EQU     00000000111000b 

 0x0                    @@p2_Black      EQU     00000000000000b 
 0x40                   @@p2_Blue       EQU     00000001000000b 
 0x80                   @@p2_Red        EQU     00000010000000b 
 0xc0                   @@p2_Tan        EQU     00000011000000b 
 0x100                  @@p2_DarkGreen  EQU     00000100000000b 
 0x140                  @@p2_Green      EQU     00000101000000b 
 0x180                  @@p2_Yellow     EQU     00000110000000b 
 0x1c0                  @@p2_Stack      EQU     00000111000000b 

 0x0                    @@p3_Black      EQU     00000000000000b 
 0x200                  @@p3_Blue       EQU     00001000000000b 
 0x400                  @@p3_Red        EQU     00010000000000b 
 0x600                  @@p3_Tan        EQU     00011000000000b 
 0x2000                 @@p3_DarkGreen  EQU     10000000000000b 
 0x2200                 @@p3_Green      EQU     10001000000000b 
 0x2400                 @@p3_Yellow     EQU     10010000000000b 
 0x2600                 @@p3_Stack      EQU     10011000000000b 

 0x0                    @@p0_BLK        EQU     00000000000000b 
 0x1                    @@p0_BLU        EQU     00000000000001b 
 0x2                    @@p0_RED        EQU     00000000000010b 
 0x3                    @@p0_TAN        EQU     00000000000011b 
 0x4                    @@p0_DGR        EQU     00000000000100b 
 0x5                    @@p0_GRN        EQU     00000000000101b 
 0x6                    @@p0_YEL        EQU     00000000000110b 
 0x7                    @@p0_STK        EQU     00000000000111b 

 0x0                    @@p1_BLK        EQU     00000000000000b 
 0x8                    @@p1_BLU        EQU     00000000001000b 
 0x10                   @@p1_RED        EQU     00000000010000b 
 0x18                   @@p1_TAN        EQU     00000000011000b 
 0x20                   @@p1_DGR        EQU     00000000100000b 
 0x28                   @@p1_GRN        EQU     00000000101000b 
 0x30                   @@p1_YEL        EQU     00000000110000b 
 0x38                   @@p1_STK        EQU     00000000111000b 

 0x0                    @@p2_BLK        EQU     00000000000000b 
 0x40                   @@p2_BLU        EQU     00000001000000b 
 0x80                   @@p2_RED        EQU     00000010000000b 
 0xc0                   @@p2_TAN        EQU     00000011000000b 
 0x100                  @@p2_DGR        EQU     00000100000000b 
 0x140                  @@p2_GRN        EQU     00000101000000b 
 0x180                  @@p2_YEL        EQU     00000110000000b 
 0x1c0                  @@p2_STK        EQU     00000111000000b 

 0x0                    @@p3_BLK        EQU     00000000000000b 
 0x200                  @@p3_BLU        EQU     00001000000000b 
 0x400                  @@p3_RED        EQU     00010000000000b 
 0x600                  @@p3_TAN        EQU     00011000000000b 
 0x2000                 @@p3_DGR        EQU     10000000000000b 
 0x2200                 @@p3_GRN        EQU     10001000000000b 
 0x2400                 @@p3_YEL        EQU     10010000000000b 
 0x2600                 @@p3_STK        EQU     10011000000000b 
			                ENDP

			;; ======================================================================== ;;
			;;  __FGBG:  Constants used by the Foreground/Background mode macros.       ;;
			;; ======================================================================== ;;
 0x32a                  __FGBG          PROC
 0x0                    @@f_Black       EQU     00000000000000b     ; foreground ==  0
 0x1                    @@f_Blue        EQU     00000000000001b     ; foreground ==  1
 0x2                    @@f_Red         EQU     00000000000010b     ; foreground ==  2
 0x3                    @@f_Tan         EQU     00000000000011b     ; foreground ==  3
 0x4                    @@f_DarkGreen   EQU     00000000000100b     ; foreground ==  4
 0x5                    @@f_Green       EQU     00000000000101b     ; foreground ==  5
 0x6                    @@f_Yellow      EQU     00000000000110b     ; foreground ==  6
 0x7                    @@f_White       EQU     00000000000111b     ; foreground ==  7

 0x0                    @@b_Black       EQU     00000000000000b     ; background ==  0
 0x200                  @@b_Blue        EQU     00001000000000b     ; background ==  1
 0x400                  @@b_Red         EQU     00010000000000b     ; background ==  2
 0x600                  @@b_Tan         EQU     00011000000000b     ; background ==  3
 0x2000                 @@b_DarkGreen   EQU     10000000000000b     ; background ==  4
 0x2200                 @@b_Green       EQU     10001000000000b     ; background ==  5
 0x2400                 @@b_Yellow      EQU     10010000000000b     ; background ==  6
 0x2600                 @@b_White       EQU     10011000000000b     ; background ==  7
 0x1000                 @@b_Grey        EQU     01000000000000b     ; background ==  8
 0x1000                 @@b_Gray        EQU     01000000000000b     ; background ==  8
 0x1200                 @@b_Cyan        EQU     01001000000000b     ; background ==  9
 0x1400                 @@b_Orange      EQU     01010000000000b     ; background == 10
 0x1600                 @@b_Brown       EQU     01011000000000b     ; background == 11
 0x3000                 @@b_Pink        EQU     11000000000000b     ; background == 12
 0x3200                 @@b_LightBlue   EQU     11001000000000b     ; background == 13
 0x3400                 @@b_YellowGreen EQU     11010000000000b     ; background == 14
 0x3600                 @@b_Purple      EQU     11011000000000b     ; background == 15

 0x0                    @@f_BLK         EQU     00000000000000b     ; foreground ==  0
 0x1                    @@f_BLU         EQU     00000000000001b     ; foreground ==  1
 0x2                    @@f_RED         EQU     00000000000010b     ; foreground ==  2
 0x3                    @@f_TAN         EQU     00000000000011b     ; foreground ==  3
 0x4                    @@f_DGR         EQU     00000000000100b     ; foreground ==  4
 0x5                    @@f_GRN         EQU     00000000000101b     ; foreground ==  5
 0x6                    @@f_YEL         EQU     00000000000110b     ; foreground ==  6
 0x7                    @@f_WHT         EQU     00000000000111b     ; foreground ==  7
			               
 0x0                    @@b_BLK         EQU     00000000000000b     ; background ==  0
 0x200                  @@b_BLU         EQU     00001000000000b     ; background ==  1
 0x400                  @@b_RED         EQU     00010000000000b     ; background ==  2
 0x600                  @@b_TAN         EQU     00011000000000b     ; background ==  3
 0x2000                 @@b_DGR         EQU     10000000000000b     ; background ==  4
 0x2200                 @@b_GRN         EQU     10001000000000b     ; background ==  5
 0x2400                 @@b_YEL         EQU     10010000000000b     ; background ==  6
 0x2600                 @@b_WHT         EQU     10011000000000b     ; background ==  7
 0x1000                 @@b_GRY         EQU     01000000000000b     ; background ==  8
 0x1200                 @@b_CYN         EQU     01001000000000b     ; background ==  9
 0x1400                 @@b_ORG         EQU     01010000000000b     ; background == 10
 0x1600                 @@b_BRN         EQU     01011000000000b     ; background == 11
 0x3000                 @@b_PNK         EQU     11000000000000b     ; background == 12
 0x3200                 @@b_LBL         EQU     11001000000000b     ; background == 13
 0x3400                 @@b_YGR         EQU     11010000000000b     ; background == 14
 0x3600                 @@b_PUR         EQU     11011000000000b     ; background == 15

 0x800                  @@GRAM          EQU     00100000000000b     ; Select card from GRAM
 0x0                    @@GROM          EQU     00000000000000b     ; Select card from GROM

			                ENDP

			;; ======================================================================== ;;
			;;  disp_ptr(r, c)                                                          ;;
			;;  Generates a pointer to display memory for a given row and column #.     ;;
			;;                                                                          ;;
			;;  ARGUMENTS                                                               ;;
			;;      r   Row number.  0 is top row, 11 is bottom row.                    ;;
			;;      c   Column number.  0 is left edge, 19 is right edge.               ;;
			;; ======================================================================== ;;
			MACRO disp_ptr(r, c)
			        ($200 + %r%*20 + %c%)
			ENDM

			;; ======================================================================== ;;
			;;  disp_ofs(r, c)                                                          ;;
			;;  Generates offset into display buffer that corresponds to a given row    ;;
			;;  and column number.                                                      ;;
			;;                                                                          ;;
			;;  ARGUMENTS                                                               ;;
			;;      r   Row number.  0 is top row, 11 is bottom row.                    ;;
			;;      c   Column number.  0 is left edge, 19 is right edge.               ;;
			;; ======================================================================== ;;
			MACRO disp_ofs(r, c)
			        (%r%*20 + %c%)
			ENDM

			;; ======================================================================== ;;
			;;  DISP_OFS    r, c                                                        ;;
			;;  Generates an offset into display memory for a given row and column #    ;;
			;;  held in registers.  Result is left in "c".  The value "r" is left       ;;
			;;  left-shifted by 4.  Both "r" and "c" must be different registers.       ;;
			;;                                                                          ;;
			;;  ARGUMENTS                                                               ;;
			;;      r   Register holding row number.  Must be R0 through R3.            ;;
			;;      c   Register holding column number.  Result will be left in this    ;;
			;;          register.                                                       ;;
			;; ======================================================================== ;;
			MACRO   DISP_OFS    r,  c
			        SLL     %r%,    2
			        ADDR    %r%,    %c%
			        SLL     %r%,    2
			        ADDR    %r%,    %c%
			ENDM

			;; ======================================================================== ;;
			;;  DISP_OFS3   r, c, rs                                                    ;;
			;;  Generates an offset into display memory for a given row and column #    ;;
			;;  held in registers.  Result is left in "rs".  Both "r" and "c" are       ;;
			;;  left unmodified.  All three arguments must point to different           ;;
			;;  registers.                                                              ;;
			;;                                                                          ;;
			;;  ARGUMENTS                                                               ;;
			;;      r   Register holding row number.                                    ;;
			;;      c   Register holding column number.                                 ;;
			;;      rs  Register to hold the result.  Must be R0 through R3.            ;;
			;; ======================================================================== ;;
			MACRO   DISP_OFS3   r,  c,  rs
			        MOVR    %r%,    %rs%
			        SLL     %rs%,   2
			        ADDR    %r%,    %rs%
			        SLL     %rs%,   2
			        ADDR    %c%,    %rs%
			ENDM

			;; ======================================================================== ;;
			;;  DISP_PTR    r, c                                                        ;;
			;;  Generates a pointer to display memory for a given row and column #      ;;
			;;  held in registers.  Result is left in "c".  The value "r" is left       ;;
			;;  left-shifted by 4.  Both "r" and "c" must be different registers.       ;;
			;;                                                                          ;;
			;;  ARGUMENTS                                                               ;;
			;;      r   Register holding row number.  Must be R0 through R3.            ;;
			;;      c   Register holding column number.  Result will be left in this    ;;
			;;          register.                                                       ;;
			;; ======================================================================== ;;
			MACRO   DISP_PTR    r,  c
			        DISP_OFS    r,  c
			        ADDI    #$200,  %c%
			ENDM

			;; ======================================================================== ;;
			;;  DISP_PTR3   r, c, rs                                                    ;;
			;;  Generates a pointer to display memory for a given row and column #      ;;
			;;  held in registers.  Result is left in "rs".  Both "r" and "c" are       ;;
			;;  left unmodified.  All three arguments must point to different           ;;
			;;  registers.                                                              ;;
			;;                                                                          ;;
			;;  ARGUMENTS                                                               ;;
			;;      r   Register holding row number.                                    ;;
			;;      c   Register holding column number.                                 ;;
			;;      rs  Register to hold the result.  Must be R0 through R3.            ;;
			;; ======================================================================== ;;
			MACRO   DISP_PTR3   r,  c
			        DISP_OFS3   r,  c,  rs
			        ADDI        #$200,  %rs%
			ENDM

			    ENDI
			            INCLUDE "macro/gfx.mac"
			;; ======================================================================== ;;
			;;  GFX.MAC                                             Default Macro Set   ;;
			;;  Macros for generating graphics bitfields from strings.                  ;;
			;;  Joseph Zbiciak <im14u2c@globalcrossing.net>                             ;;
			;;  These macros are hereby released into the Public Domain.                ;;
			;;                                                                          ;;
			;;  Macros defined in this file:                                            ;;
			;;      gfx_start    Start a packed graphic                                 ;;
			;;      gfx_row s    Add an 8-pixel wide row to a packed graphic            ;;
			;;      gfx_flush    End a packed graphic                                   ;;
			;;                                                                          ;;
			;;  EXAMPLE USAGE:                                                          ;;
			;;                                                                          ;;
			;;      gfx_start                                                           ;;
			;;      gfx_row   ".######."                                                ;;
			;;      gfx_row   "#......#"                                                ;;
			;;      gfx_row   "#.#..#.#"                                                ;;
			;;      gfx_row   "#......#"                                                ;;
			;;      gfx_row   "#.#..#.#"                                                ;;
			;;      gfx_row   "#..##..#"                                                ;;
			;;      gfx_row   "#......#"                                                ;;
			;;      gfx_row   ".######."                                                ;;
			;;      gfx_flush                                                           ;;
			;;                                                                          ;;
			;;  The above will generate the following four words in memory:             ;;
			;;                                                                          ;;
			;;      Hex       Binary                                                    ;;
			;;      817E      1000 0001 0111 1110                                       ;;
			;;      81A5      1000 0001 1010 0101                                       ;;
			;;      99A5      1001 1001 1010 0101                                       ;;
			;;      7E81      0111 1110 1000 0001                                       ;;
			;;                                                                          ;;
			;;  As you can see, the even rows (0, 2, 4, 6) of the bitmap are in         ;;
			;;  the lower bytes of each of the 4 words.  The odd rows of the bitmap     ;;
			;;  are in the upper bytes.                                                 ;;
			;;                                                                          ;;
			;;  A loop like the following is suitable for copying such a bitmap to      ;;
			;;  GRAM:                                                                   ;;
			;;                                                                          ;;
			;;     REPEAT 4                                                             ;;
			;;     MVI@   R4, R0 ; get next two rows                                    ;;
			;;     MVO@   R0, R5 ; write even # row                                     ;;
			;;     SWAP   R0                                                            ;;
			;;     MVO@   R0, R5 ; write odd # row                                      ;;
			;;     ENDR                                                                 ;;
			;;                                                                          ;;
			;;  Note that the macros do not keep track of how tall the graphic is.      ;;
			;;  They only track whether an even number or odd number of lines has       ;;
			;;  been written.                                                           ;;
			;; ======================================================================== ;;

			    IF (DEFINED _GFX_MAC) = 0

 0x1                    _GFX_MAC EQU 1

			;; ======================================================================== ;;
			;;  gfx_start                                                               ;;
			;;  Initializes symbols for the string->bitmap graphic generator.           ;;
			;; ======================================================================== ;;
			MACRO   gfx_start
			        LISTING "code"
			_gfx_w  SET 0
			_gfx_eo SET 0
			        LISTING "prev"
			ENDM

			;; ======================================================================== ;;
			;;  gfx_row s                                                               ;;
			;;  Takes a string, and generates a row of bitmap from the first 8          ;;
			;;  characters in the string.  Space characters and dot characters are      ;;
			;;  mapped to '0' bits in the bitmap.  All others are mapped to 1.  If the  ;;
			;;  string is shorter than 8 characters, the missing characters are mapped  ;;
			;;  to 0.                                                                   ;;
			;;                                                                          ;;
			;;  The bitmap is output as a series of DECLE statements.  Even numbered    ;;
			;;  rows are stored in the lower byte of each 16-bit word.  Odd numbered    ;;
			;;  rows are stored in the upper byte of each 16-bit word.                  ;;
			;;                                                                          ;;
			;;  ARGUMENTS                                                               ;;
			;;      s   String to convert into a bitmap.                                ;;
			;; ======================================================================== ;;
			MACRO   gfx_row s
			        LISTING "code"
			        ; start of graphics definition
			_gfx_x  SET 0
			_gfx_b  SET $8000
			_gfx_w  SET (_gfx_w SHR 8)
			        REPEAT 8
			_gfx_w  SET (_gfx_w + _gfx_b*((ASC(%s%,_gfx_x)<>$20) AND (ASC(%s%,_gfx_x)<>$2E) AND (ASC(%s%,_gfx_x)<>0)))
			_gfx_x  SET _gfx_x + 1
			_gfx_b  SET _gfx_b SHR 1
			        ENDR
			_gfx_eo SET _gfx_eo + 1
			        IF  _gfx_eo = 2
			        DECLE _gfx_w
			_gfx_eo SET 0
			        ENDI
			        LISTING "prev"
			ENDM

			;; ======================================================================== ;;
			;;  gfx_flush                                                               ;;
			;;  Ensures that all bitmap data for a packed bitmap is output.  That is,   ;;
			;;  if any rows of bitmap are waiting to be pushed to the object file,      ;;
			;;  this macro will push those to the object file.  In general, each        ;;
			;;  bitmap definition should be followed by gfx_flush.                      ;;
			;; ======================================================================== ;;
			MACRO   gfx_flush 
			        LISTING "code"
			        IF _gfx_eo = 1
			        DECLE _gfx_w SHR 8
			        ENDI
			_gfx_w  SET 0
			_gfx_eo SET 0
			        LISTING "prev"
			ENDM

			    ENDI
			            INCLUDE "macro/print.mac"
			;; ======================================================================== ;;
			;;  PRINT.MAC                                           Default Macro Set   ;;
			;;  Macros that simplify printing.                                          ;;
			;;  Joseph Zbiciak <im14u2c@globalcrossing.net>                             ;;
			;;  These macros are hereby released into the Public Domain.                ;;
			;; ======================================================================== ;; 

			    IF (DEFINED _PRINT_MAC) = 0

 0x1                    _PRINT_MAC EQU 1

			;; ======================================================================== ;;
			;;  PRINT_CSTK r, c, fg, s                                                  ;;
			;;  Prints a string at r, c, in foreground color 'fg', using SDK-1600's     ;;
			;;  PRINT.FLS.  This macro is intended for use in color-stack mode.         ;;
			;;  This macro adds terminating NUL to the string for you.                  ;;
			;;                                                                          ;;
			;;  ARGUMENTS                                                               ;;
			;;      r   Row to print string at                                          ;;
			;;      c   Column to print string at                                       ;;
			;;      fg  Color to print string in                                        ;;
			;;      s   String to print.                                                ;;
			;;                                                                          ;;
			;;  EXAMPLE                                                                 ;;
			;;      PRINT_CSTK 10, 5, Yellow, "Hello World!"                            ;;
			;; ======================================================================== ;;
			MACRO   PRINT_CSTK r, c, fg, s
			        CALL    PRINT.FLS
			        DECLE   gen_cstk_card(0, GROM, %fg%, NoAdvance)
			        DECLE   disp_ptr(%r%, %c%)
			        STRING  %s%, 0
			ENDM

			;; ======================================================================== ;;
			;;  PRINT_FGBG r, c, fg, bg, s                                              ;;
			;;  Prints a string at r, c, in foreground color 'fg' and background color  ;;
			;;  'bg', using SDK-1600's PRINT.FLS.  This macro is intended for use in    ;;
			;;  Foreground/Background mode.  This macro adds terminating NUL to the     ;;
			;;  string for you.                                                         ;;
			;;                                                                          ;;
			;;  ARGUMENTS                                                               ;;
			;;      r   Row to print string at                                          ;;
			;;      c   Column to print string at                                       ;;
			;;      fg  Foreground color for string                                     ;;
			;;      bg  Background color for string                                     ;;
			;;      s   String to print.                                                ;;
			;;                                                                          ;;
			;;  EXAMPLE                                                                 ;;
			;;      PRINT_FGBG 10, 5, Yellow, Blue, "Hello World!"                      ;;
			;; ======================================================================== ;;
			MACRO   PRINT_FGBG r, c, fg, bg, s
			        CALL    PRINT.FLS
			        DECLE   gen_fgbg_card(0, GROM, %fg%, %bg%)
			        DECLE   disp_ptr(%r%, %c%)
			        STRING  %s%, 0
			ENDM

			    ENDI

 0x5000                             ORG     $5000           ; Use default memory map

			;; ======================================================================== ;;
			;;  EXEC-friendly ROM header.                                               ;;
			;; ======================================================================== ;;
5000 000d 0050 		ROMHDR:     BIDECLE ZERO            ; MOB picture base   (points to NULL list)
5002 000d 0050 		            BIDECLE ZERO            ; Process table      (points to NULL list)
5004 002a 0050 		            BIDECLE MAIN            ; Program start address
5006 000d 0050 		            BIDECLE ZERO            ; Bkgnd picture base (points to NULL list)
5008 000f 0050 		            BIDECLE ONES            ; GRAM pictures      (points to NULL list)
500a 0014 0050 		            BIDECLE TITLE           ; Cartridge title/date
500c 03c0 		            DECLE   $03C0           ; No ECS title, run code after title,
			                                    ; ... no clicks
500d 0000 		ZERO:       DECLE   $0000           ; Screen border control
500e 0000 		            DECLE   $0000           ; 0 = color stack, 1 = f/b mode
500f 0001 0001 0001 	ONES:       DECLE   1, 1, 1, 1, 1   ; Initial color stack 0..3 and border: blue
5012 0001 0001 
			;------------------------------------------------------------------------------

			;; ======================================================================== ;;
			;;  EMUlink API subfunctions for joysticks:                                 ;;
			;;                                                                          ;;
			;;    00: Number of joysticks.  Result in R0.  Ignores R3.                  ;;
			;;    01: Get geometry: Returns # of axes, balls, hats, buttons in R0..R3   ;;
			;;    02: Get X/Y raw pos:  Returns 16-bit X/Y pos in R1, R2.               ;;
			;;    03: Get X/Y raw min:  Returns 16-bit X/Y min in R1, R2.               ;;
			;;    04: Get X/Y raw max:  Returns 16-bit X/Y max in R1, R2.               ;;
			;;    05: Get X/Y raw ctr:  Returns 16-bit X/Y max in R1, R2.               ;;
			;;    06: Get X/Y cooked:   Norm'd 8-bit X/Y in R1, R2. Disc Dir in R0.     ;;
			;;    07: Get buttons.  Returns 32-bit bitmap in R1, R2.                    ;;
			;;    08: Get hats.  Returns hats 0..3 in 4 x 4-bit fields in R0.           ;;
			;; ======================================================================== ;;

 0x0                    EL_NUM_JOY  EQU 0 
 0x1                    EL_GET_GEO  EQU 1
 0x2                    EL_RAW_POS  EQU 2
 0x3                    EL_RAW_MIN  EQU 3
 0x4                    EL_RAW_MAX  EQU 4
 0x5                    EL_RAW_CTR  EQU 5
 0x6                    EL_GET_XY   EQU 6
 0x7                    EL_GET_BTN  EQU 7
 0x8                    EL_GET_HAT  EQU 8

			;; ======================================================================== ;;
			;;  TITLE  -- Display our modified title screen & copyright date.           ;;
			;; ======================================================================== ;;
 0x5014                 TITLE:      PROC
5014 0069 004a 006f 	            BYTE    105, 'Joystick Diagnostics', 0
5017 0079 0073 0074 0069 0063 006b 0020 0044 
501f 0069 0061 0067 006e 006f 0073 0074 0069 
5027 0063 0073 0000 
			           
 0x502a                 MAIN:
502a 02bc 0100 		            MVII    #$100,  R4
502c 02b9 0260 		            MVII    #$260,  R1
502e 0004 0150 0168 	            CALL    FILLZERO

5031 02b8 50d8 		            MVII    #ISR,   R0
5033 0240 0100 		            MVO     R0,     $100
5035 0040 		            SWAP    R0
5036 0240 0101 		            MVO     R0,     $101
5038 02be 02f0 		            MVII    #$2F0,  R6

503a 0002 		            EIS
			           
			            ;; ------------------------------------------------------------ ;;
			            ;;  Check for EMU_LINK support.                                 ;;
			            ;; ------------------------------------------------------------ ;;
503b 02b8 4a5a 		            MVII    #$4A5A, R0
503d 0007 		            SETC
503e 0036 		            SIN
503f 0209 0032 		            BNC     @@ok
5041 0080 		            TSTR    R0
5042 0204 002f 		            BEQ     @@ok
			           
			            ;; ------------------------------------------------------------ ;;
			            ;;  Print failure message if we don't detect EMU_LINK.          ;;
			            ;; ------------------------------------------------------------ ;;
			                                  ;0123456789012345678901234567890123456789
			;           PRINT_CSTK 6, 1, RED, "   Requires jzIntv    EMU-LINK support."
5044 0004 0150 0144 	            CALL    PRINT.FLS
5047 0002 		        DECLE   (0*8 + __CSTK.GROM_RED + __CSTK.NoAdvance)
5048 0279 		        DECLE   ($200 + 6*20 + 1)
5049 0020 0020 0020 	        STRING  "   Requires jzIntv    EMU-LINK support.", 0
504c 0052 0065 0071 0075 0069 0072 0065 0073 
5054 0020 006a 007a 0049 006e 0074 0076 0020 
505c 0020 0020 0020 0045 004d 0055 002d 004c 
5064 0049 004e 004b 0020 0073 0075 0070 0070 
506c 006f 0072 0074 002e 0000 
5071 0220 0001 		            B       $

 0x5073                 @@ok:
			            ;; ------------------------------------------------------------ ;;
			            ;;  See if any joysticks are hooked up.                         ;;
			            ;; ------------------------------------------------------------ ;;
5073 0004 0150 00f6 	            CALL    DO_EL
5076 0000 		            DECLE   EL_NUM_JOY

5077 0080 		            TSTR    R0
5078 020c 001c 		            BNEQ    @@got_joy
			                                  ;0123456789012345678901234567890123456789
			;           PRINT_CSTK 6, 1, RED, "No Joystics Detected"
507a 0004 0150 0144 	            CALL    PRINT.FLS
507d 0002 		        DECLE   (0*8 + __CSTK.GROM_RED + __CSTK.NoAdvance)
507e 0279 		        DECLE   ($200 + 6*20 + 1)
507f 004e 006f 0020 	        STRING  "No Joystics Detected", 0
5082 004a 006f 0079 0073 0074 0069 0063 0073 
508a 0020 0044 0065 0074 0065 0063 0074 0065 
5092 0064 0000 
5094 0220 0001 		            B       $

5096 0240 0300 		@@got_joy   MVO     R0, NUM_JOY

			            ;; ------------------------------------------------------------ ;;
			            ;;  Main processing loop.  Read info about current controller   ;;
			            ;;  and display it.                                             ;;
			            ;; ------------------------------------------------------------ ;;
 0x5098                 @@loop:
5098 0004 0150 0139 	            CALL    GET_RAW
509b 0302 0002 		            DECLE   RAW_POS, EL_RAW_POS

509d 0004 0150 0139 	            CALL    GET_RAW
50a0 0304 0005 		            DECLE   RAW_CTR, EL_RAW_CTR

50a2 0004 0150 0139 	            CALL    GET_RAW
50a5 0306 0003 		            DECLE   RAW_MIN, EL_RAW_MIN

50a7 0004 0150 0139 	            CALL    GET_RAW
50aa 0308 0004 		            DECLE   RAW_MAX, EL_RAW_MAX

50ac 0004 0150 0139 	            CALL    GET_RAW
50af 030a 0006 		            DECLE   NRM_POS, EL_GET_XY
50b1 0240 030c 		            MVO     R0, DISC

50b3 0004 0150 0139 	            CALL    GET_RAW
50b6 030e 0007 		            DECLE   BUTTONS, EL_GET_BTN

			;           CALL    DO_EL
			;           DECLE   EL_GET_HAT
			;           MVO     R0, HATS
			    
50b8 0004 0150 00e4 	            CALL    DISP_PAIR
			;           DECLE   RAW_POS, disp_ptr(1, 0)
50bb 0302 0214 		            DECLE   RAW_POS, ($200 + 1*20 + 0)
			    
50bd 0004 0150 00e4 	            CALL    DISP_PAIR
			;           DECLE   RAW_CTR, disp_ptr(2, 0)
50c0 0304 0228 		            DECLE   RAW_CTR, ($200 + 2*20 + 0)
			    
50c2 0004 0150 00e4 	            CALL    DISP_PAIR
			;           DECLE   RAW_MIN, disp_ptr(3, 0)
50c5 0306 023c 		            DECLE   RAW_MIN, ($200 + 3*20 + 0)
			    
50c7 0004 0150 00e4 	            CALL    DISP_PAIR
			;           DECLE   RAW_MAX, disp_ptr(4, 0)
50ca 0308 0250 		            DECLE   RAW_MAX, ($200 + 4*20 + 0)

50cc 0004 0150 00e4 	            CALL    DISP_PAIR
			;           DECLE   NRM_POS, disp_ptr(5, 0)
50cf 030a 0264 		            DECLE   NRM_POS, ($200 + 5*20 + 0)

50d1 0004 0150 00e4 	            CALL    DISP_PAIR
			;           DECLE   BUTTONS, disp_ptr(6, 0)
50d4 030e 0278 		            DECLE   BUTTONS, ($200 + 6*20 + 0)

50d6 0220 003f 		            B       @@loop

			            ; Done.
			            ENDP
			           
			;; ======================================================================== ;;
			;;  ISR                                                                     ;;
			;; ======================================================================== ;;
 0x50d8                 ISR         PROC
50d8 0240 0020 		            MVO     R0,     $20
50da 02b8 0003 		            MVII    #__CSTK.GROM_TAN, R0
50dc 02bc 0028 		            MVII    #$28,   R4
50de 0260 		            MVO@    R0,     R4
50df 0260 		            MVO@    R0,     R4
50e0 0260 		            MVO@    R0,     R4
50e1 0260 		            MVO@    R0,     R4
50e2 0260 		            MVO@    R0,     R4
50e3 00af 		            JR      R5
			            ENDP

			;; ======================================================================== ;;
			;;  DISP_PAIR                                                               ;;
			;; ======================================================================== ;;
 0x50e4                 DISP_PAIR   PROC
50e4 02ab 		            MVI@    R5,     R3
50e5 02ac 		            MVI@    R5,     R4
50e6 0275 		            PSHR    R5

50e7 0298 		            MVI@    R3,     R0
50e8 000b 		            INCR    R3
50e9 0273 		            PSHR    R3
50ea 02b9 0007 		            MVII    #__CSTK.GROM_WHT, R1
50ec 0004 0150 01b7 	            CALL    HEX16

50ef 000c 		            INCR    R4
50f0 02b3 		            PULR    R3
50f1 0298 		            MVI@    R3,     R0
50f2 0004 0150 01b7 	            CALL    HEX16

50f5 02b7 		            PULR    PC
			            ENDP

			;; ======================================================================== ;;
			;;  DO_EL   Make an joystick emu_link call.  API follows call.              ;;
			;;  DO_EL.1 Make an joystick emu_link call.  API in R2.                     ;;
			;; ======================================================================== ;;
 0x50f6                 DO_EL       PROC
50f6 02aa 		            MVI@    R5,     R2
50f7 02b8 4a5a 		@@1         MVII    #$4A5A, R0
50f9 0275 		            PSHR    R5
50fa 0272 		            PSHR    R2
50fb 02b9 0008 		            MVII    #8,     R1
50fd 0007 		            SETC
50fe 0036 		            SIN
50ff 0201 0002 		            BC      @@failed
5101 0016 		            DECR    R6          ; dump saved EL call #
5102 02b7 		            PULR    PC          ; return

5103 0004 0150 0164 	@@failed:   CALL    CLRSCR
			;           MVII    #disp_ptr(7, 2), R4
5106 02bc 028e 		            MVII    #($200 + 7*20 + 2), R4
5108 02b9 0002 		            MVII    #__CSTK.GROM_RED, R1
510a 0004 0150 01b7 	            CALL    HEX16
			                                   ;0123456789012345678901234567890123456789
			;           PRINT_CSTK  5, 0, RED, "EMU-LINK call failed"
510d 0004 0150 0144 	            CALL    PRINT.FLS
5110 0002 		        DECLE   (0*8 + __CSTK.GROM_RED + __CSTK.NoAdvance)
5111 0264 		        DECLE   ($200 + 5*20 + 0)
5112 0045 004d 0055 	        STRING  "EMU-LINK call failed", 0
5115 002d 004c 0049 004e 004b 0020 0063 0061 
511d 006c 006c 0020 0066 0061 0069 006c 0065 
5125 0064 0000 
5127 02b0 		            PULR    R0
			;           MVII    #disp_ptr(7, 7), R4
5128 02bc 0293 		            MVII    #($200 + 7*20 + 7), R4
512a 02b9 0002 		            MVII    #__CSTK.GROM_RED, R1
512c 0004 0150 01b7 	            CALL    HEX16

512f 02b0 		            PULR    R0
			;           MVII    #disp_ptr(7,12), R4
5130 02bc 0298 		            MVII    #($200 + 7*20 + 12), R4
5132 02b9 0002 		            MVII    #__CSTK.GROM_RED, R1
5134 0004 0150 01b7 	            CALL    HEX16

5137 0220 0001 		            B       $
			            ENDP

			;; ======================================================================== ;;
			;;  GET_RAW:  EL calls RAW_POS thru RAW_CTR                                 ;;
			;; ======================================================================== ;;
 0x5139                 GET_RAW     PROC
5139 02ac 		            MVI@    R5,     R4
513a 02aa 		            MVI@    R5,     R2      ; Sub-API number
513b 0275 		            PSHR    R5
513c 0283 0301 		            MVI     CUR_JOY,R3      ; Current joystick number
513e 0004 0150 00f7 	            CALL    DO_EL.1
5141 0261 		            MVO@    R1,     R4
5142 0262 		            MVO@    R2,     R4
5143 02b7 		            PULR    PC
			            ENDP

			;; ======================================================================== ;;
			;;  LIBRARY INCLUDES                                                        ;;
			;; ======================================================================== ;;
			            INCLUDE "library/print.asm"
			;;==========================================================================;;
			;;  Useful Routines                                                         ;;
			;;  Copyright 1999-2002, Joe Zbiciak.                                       ;;
			;;                                                                          ;;
			;;  This file contains a number of useful routines that you're welcome      ;;
			;;  to use in your own software.  Please keep in mind that these routines   ;;
			;;  are licensed under the GNU General Public License, and so if you plan   ;;
			;;  to distribute a program which incorporates these routines, it too must  ;;
			;;  be distributed under the GNU General Public License.                    ;;
			;;==========================================================================;;

			;; ======================================================================== ;;
			;;  PRINT.xxx     Prints an ASCIIZ string.                                  ;;
			;;                                                                          ;;
			;;  PRINT.R       Ptr to string in R0, format in R1, location in R4.        ;;
			;;  PRINT.S       String follows CALL.  Format in R1, location in R4.       ;;
			;;  PRINT.LS      Location and string itself follows CALL.  Format in R1.   ;;
			;;  PRINT.FLS     Format, location, and string itself follows CALL          ;;
			;;  PRINT.P       Ptr to string follows CALL.  Format in R1, loc. in R4.    ;;
			;;  PRINT.LP      Location and ptr to string follows CALL.  Format in R1.   ;;
			;;  PRINT.FLP     Format, location, and ptr to string follows CALL          ;;
			;;                                                                          ;;
			;;  PRINT alone is an alias for PRINT.FLS.                                  ;;
			;;                                                                          ;;
			;;  INPUTS for PRINT.R:                                                     ;;
			;;      R0 -- Pointer to ASCIIZ string                                      ;;
			;;      R1 -- Screen format word                                            ;;
			;;      R4 -- Pointer to display location                                   ;;
			;;      R5 -- Return address                                                ;;
			;;                                                                          ;;
			;;  INPUTS for PRINT.S:                                                     ;;
			;;      R1 -- Screen format word                                            ;;
			;;      R4 -- Pointer to display location                                   ;;
			;;      R5 -- Invocation record, followed by return code.                   ;;
			;;              String                      n DECLEs (NUL terminated)       ;;
			;;                                                                          ;;
			;;  INPUTS for PRINT.LS:                                                    ;;
			;;      R1 -- Screen format word                                            ;;
			;;      R5 -- Invocation record, followed by return code.                   ;;
			;;              Ptr to display location     1 DECLE                         ;;
			;;              String                      n DECLEs (NUL terminated)       ;;
			;;                                                                          ;;
			;;  INPUTS for PRINT.FLS:                                                   ;;
			;;      R5 -- Invocation record, followed by return code.                   ;;
			;;              Screen format word          1 DECLE                         ;;
			;;              Ptr to display location     1 DECLE                         ;;
			;;              String                      n DECLEs (NUL terminated)       ;;
			;;                                                                          ;;
			;;  INPUTS for PRINT.P:                                                     ;;
			;;      R1 -- Screen format word                                            ;;
			;;      R4 -- Pointer to display location                                   ;;
			;;      R5 -- Invocation record, followed by return code.                   ;;
			;;              Pointer to ASCIIZ string    1 DECLE                         ;;
			;;                                                                          ;;
			;;  INPUTS for PRINT.LP:                                                    ;;
			;;      R1 -- Screen format word                                            ;;
			;;      R5 -- Invocation record, followed by return code.                   ;;
			;;              Ptr to display location     1 DECLE                         ;;
			;;              Pointer to ASCIIZ string    1 DECLE                         ;;
			;;                                                                          ;;
			;;  INPUTS for PRINT.FLP:                                                   ;;
			;;      R5 -- Invocation record, followed by return code.                   ;;
			;;              Screen format word          1 DECLE                         ;;
			;;              Location                    1 DECLE                         ;;
			;;              Pointer to ASCIIZ string    1 DECLE                         ;;
			;;                                                                          ;;
			;;  OUTPUTS:                                                                ;;
			;;      R0 -- Trashed                                                       ;;
			;;      R1 -- Same as screen format word, EXCEPT Bit 15 is cleared.         ;;
			;;      R4 -- Points to display location just after displayed string.       ;;
			;;      R5 -- Points just past end of source string in memory.              ;;
			;;      R2 and R3 are not modified.                                         ;;
			;;                                                                          ;;
			;;  NOTES                                                                   ;;
			;;      ASCIIZ strings are ASCII strings that are terminated with a         ;;
			;;      single NUL character.  Although it was originally intended for use  ;;
			;;      with ASCII strings, this routine does allow for characters outside  ;;
			;;      the normal range of ASCII characters as well.  This can be useful   ;;
			;;      for displaying graphic characters within a string.                  ;;
			;;                                                                          ;;
			;;      The card # displayed for a given character in the string is given   ;;
			;;      by the following formula:                                           ;;
			;;                                                                          ;;
			;;          (character_number - 32) + (format_word SHR 3) = card_number.    ;;
			;;                                                                          ;;
			;;      To display a single character from GRAM, for instance, just         ;;
			;;      insert a word whose value is "GRAM_picture_number + 288" in your    ;;
			;;      string.                                                             ;;
			;;                                                                          ;;
			;;      You can use PRINT to display entire strings of characters in        ;;
			;;      alternate fonts (such as a font loaded in GRAM) as well.  To do     ;;
			;;      this, merely add the appropriate offset to the format_word.         ;;
			;;      The correct offset depends on what characters are in your font      ;;
			;;      and where your font begins in GRAM.                                 ;;
			;;                                                                          ;;
			;;      For example, suppose your font only contains uppercase alphabetic   ;;
			;;      characters, and is loaded in GRAM positions 10 through 35.  That    ;;
			;;      is, the picture for 'A' is in GRAM position #10, and 'Z' is in      ;;
			;;      GRAM position #35.  We want 'A' to map to GRAM position #10.        ;;
			;;      GRAM position #10 is equivalent to card #266.  The ASCII value for  ;;
			;;      'A' is 65.  Using the relationship given above, we have:            ;;
			;;                                                                          ;;
			;;          (character_number - 32) + (format_word SHR 3) = card_number.    ;;
			;;          (        65       - 32) + (format_word SHR 3) = 266             ;;
			;;                                                                          ;;
			;;      Solving this, we get:                                               ;;
			;;                                                                          ;;
			;;          format_word SHR 3 = 233                                         ;;
			;;          format_word       = 233 SHL 3                                   ;;
			;;                                                                          ;;
			;;      So, to display this particular GRAM font, we must add 233 SHL 3     ;;
			;;      to our format word.  (We can still set other bits in the format     ;;
			;;      word to control its color, etc.)                                    ;;
			;; ======================================================================== ;;
 0x5144                 PRINT   PROC
5144 02a9 		@@FLS:  MVI@    R5,     R1      ; Load format word from invoc. record
5145 02ac 		@@LS:   MVI@    R5,     R4      ; Load ptr to display loc from invoc record
5146 0200 0007 		        B       @@S             ; Continue w/ string pointer in R5.

5148 02a9 		@@FLP:  MVI@    R5,     R1      ; Load ptr to string from invoc. record
5149 02ac 		@@LP:   MVI@    R5,     R4      ; Load format word from invoc. record
514a 02a8 		@@P:    MVI@    R5,     R0      ; Load ptr to display loc from invoc record

514b 0275 		@@R:    PSHR    R5              ; Save return address if string ptr is in R0
514c 0085 		        MOVR    R0,     R5      ; Use auto-incr pointer for reading string
514d 0007 		        SETC                    ; Flag:  C==1 means ret addr is on stack
514e 000f 		        INCR    PC              ; Skip the CLRC.

514f 0006 		@@S     CLRC                    ; Flag:  C==0 means return after string.
5150 0049 		        SLL     R1,     1       ; \__ Hide the flag in MSB of screen fmt word
5151 0071 		        RRC     R1,     1       ; /
5152 0200 0006 		        B       @@1st           ; Get first char of string
 0x5154                 @@tloop:
5154 0338 0020 		        SUBI    #32,    R0      ; Shift ASCII range to charset
5156 004c 		        SLL     R0,     2       ; Move it to position for BTAB word
5157 0048 		        SLL     R0,     1
5158 00c8 		        ADDR    R1,     R0      ; Merge with color info
5159 0260 		        MVO@    R0,     R4      ; Write to display
515a 02a8 		@@1st:  MVI@    R5,     R0      ; Get next character
515b 0080 		        TSTR    R0              ; Is it NUL?
515c 022c 0009 		        BNEQ    @@tloop         ; --> No, keep copying then

515e 0059 		        SLLC    R1,     1       ; Get "return-to-stack" flag from MSB
515f 0028 		        ADCR    R0              ; R0 is either 0 or 1 now based on flag
5160 0061 		        SLR     R1,     1       ; Restore screen fmt word, clearing MSB.
5161 00c7 		        ADDR    R0,     PC      ; Conditionally skip JR R5 if return-to-stack
5162 00af 		        JR      R5              ; Return to R5 if flag was clear
5163 02b7 		        PULR    PC              ; Return to saved address if flag was set.
			        ENDP

			;* ======================================================================== *;
			;*  This program is free software; you can redistribute it and/or modify    *;
			;*  it under the terms of the GNU General Public License as published by    *;
			;*  the Free Software Foundation; either version 2 of the License, or       *;
			;*  (at your option) any later version.                                     *;
			;*                                                                          *;
			;*  This program is distributed in the hope that it will be useful,         *;
			;*  but WITHOUT ANY WARRANTY; without even the implied warranty of          *;
			;*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU       *;
			;*  General Public License for more details.                                *;
			;*                                                                          *;
			;*  You should have received a copy of the GNU General Public License       *;
			;*  along with this program; if not, write to the Free Software             *;
			;*  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.               *;
			;* ======================================================================== *;
			;*                Copyright (c) 1999-2002, Joseph Zbiciak                   *;
			;* ======================================================================== *;
			            INCLUDE "library/fillmem.asm"
			;;==========================================================================;;
			;;  Useful Routines                                                         ;;
			;;  Copyright 1999-2002, Joe Zbiciak.                                       ;;
			;;                                                                          ;;
			;;  This file contains a number of useful routines that you're welcome      ;;
			;;  to use in your own software.  Please keep in mind that these routines   ;;
			;;  are licensed under the GNU General Public License, and so if you plan   ;;
			;;  to distribute a program which incorporates these routines, it too must  ;;
			;;  be distributed under the GNU General Public License.                    ;;
			;;==========================================================================;;

			;; ======================================================================== ;;
			;;  FILLZERO                                                                ;;
			;;      Fills memory with zeros                                             ;;
			;;                                                                          ;;
			;;  FILLMEM                                                                 ;;
			;;      Fills memory with a constant                                        ;;
			;;                                                                          ;;
			;;  INPUTS:                                                                 ;;
			;;      R0 -- Fill value (FILLMEM only)                                     ;;
			;;      R1 -- Number of words to fill                                       ;;
			;;      R4 -- Start of fill area                                            ;;
			;;      R5 -- Return address                                                ;;
			;;                                                                          ;;
			;;  OUTPUTS:                                                                ;;
			;;      R0 -- Zeroed if FILLZERO, otherwise untouched.                      ;;
			;;      R1 -- Zeroed                                                        ;;
			;;      R4 -- Points to word after fill area                                ;;
			;; ======================================================================== ;;
 0x5164                 CLRSCR      PROC
5164 02b9 00f0 		            MVII    #$0F0,  R1
5166 02bc 0200 		            MVII    #$200,  R4
5168 01c0 		FILLZERO    CLRR    R0              ; Start out with R0 zeroed for FILLZERO
5169 0260 		FILLMEM     MVO@    R0,     R4      ; Store R0 out at R4, and move along
516a 0011 		            DECR    R1              ; Keep going until our count runs out
516b 022c 0003 		            BNEQ    FILLMEM
516d 00af 		            JR      R5              ; Return to the caller.
			            ENDP
			        
			;* ======================================================================== *;
			;*  This program is free software; you can redistribute it and/or modify    *;
			;*  it under the terms of the GNU General Public License as published by    *;
			;*  the Free Software Foundation; either version 2 of the License, or       *;
			;*  (at your option) any later version.                                     *;
			;*                                                                          *;
			;*  This program is distributed in the hope that it will be useful,         *;
			;*  but WITHOUT ANY WARRANTY; without even the implied warranty of          *;
			;*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU       *;
			;*  General Public License for more details.                                *;
			;*                                                                          *;
			;*  You should have received a copy of the GNU General Public License       *;
			;*  along with this program; if not, write to the Free Software             *;
			;*  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.               *;
			;* ======================================================================== *;
			;*                Copyright (c) 1999-2002, Joseph Zbiciak                   *;
			;* ======================================================================== *;
			            INCLUDE "library/prnum16.asm"

			;; ======================================================================== ;;
			;;  _PW10                                                                   ;;
			;;      Lookup table holding the first 5 powers of 10 (1 thru 10000) as     ;;
			;;      16-bit numbers.                                                     ;;
			;; ======================================================================== ;;
			    IF (DEFINED _PW10) = 0
 0x516e                 _PW10   PROC    ; 0 thru 10000
516e 2710 03e8 0064 	        DECLE   10000, 1000, 100, 10, 1, 0
5171 000a 0001 0000 
			        ENDP
			    ENDI

			;; ======================================================================== ;;
			;;  PRNUM16.l     -- Print an unsigned 16-bit number left-justified.        ;;
			;;  PRNUM16.b     -- Print an unsigned 16-bit number with leading blanks.   ;;
			;;  PRNUM16.z     -- Print an unsigned 16-bit number with leading zeros.    ;;
			;;                                                                          ;;
			;;  AUTHOR                                                                  ;;
			;;      Joseph Zbiciak  <im14u2c AT globalcrossing DOT net>                 ;;
			;;                                                                          ;;
			;;  REVISION HISTORY                                                        ;;
			;;      30-Mar-2003 Initial complete revision                               ;;
			;;                                                                          ;;
			;;  INPUTS for all variants                                                 ;;
			;;      R0  Number to print.                                                ;;
			;;      R2  Width of field.  Ignored by PRNUM16.l.                          ;;
			;;      R3  Format word, added to digits to set the color.                  ;;
			;;          Note:  Bit 15 MUST be cleared when building with PRNUM32.       ;;
			;;      R4  Pointer to location on screen to print number                   ;;
			;;                                                                          ;;
			;;  OUTPUTS                                                                 ;;
			;;      R0  Zeroed                                                          ;;
			;;      R1  Unmodified                                                      ;;
			;;      R2  Unmodified                                                      ;;
			;;      R3  Unmodified                                                      ;;
			;;      R4  Points to first character after field.                          ;;
			;;                                                                          ;;
			;;  DESCRIPTION                                                             ;;
			;;      These routines print unsigned 16-bit numbers in a field up to 5     ;;
			;;      positions wide.  The number is printed either in left-justified     ;;
			;;      or right-justified format.  Right-justified numbers are padded      ;;
			;;      with leading blanks or leading zeros.  Left-justified numbers       ;;
			;;      are not padded on the right.                                        ;;
			;;                                                                          ;;
			;;      This code handles fields wider than 5 characters, padding with      ;;
			;;      zeros or blanks as necessary.                                       ;;
			;;                                                                          ;;
			;;              Routine      Value(hex)     Field        Output             ;;
			;;              ----------   ----------   ----------   ----------           ;;
			;;              PRNUM16.l      $0045         n/a        "69"                ;;
			;;              PRNUM16.b      $0045          4         "  69"              ;;
			;;              PRNUM16.b      $0045          6         "    69"            ;;
			;;              PRNUM16.z      $0045          4         "0069"              ;;
			;;              PRNUM16.z      $0045          6         "000069"            ;;
			;;                                                                          ;;
			;;  TECHNIQUES                                                              ;;
			;;      This routine uses repeated subtraction to divide the number         ;;
			;;      to display by various powers of 10.  This is cheaper than a         ;;
			;;      full divide, at least when the input number is large.  It's         ;;
			;;      also easier to get right.  :-)                                      ;;
			;;                                                                          ;;
			;;      The printing routine first pads out fields wider than 5 spaces      ;;
			;;      with zeros or blanks as requested.  It then scans the power-of-10   ;;
			;;      table looking for the first power of 10 that is <= the number to    ;;
			;;      display.  While scanning for this power of 10, it outputs leading   ;;
			;;      blanks or zeros, if requested.  This eliminates "leading digit"     ;;
			;;      logic from the main digit loop.                                     ;;
			;;                                                                          ;;
			;;      Once in the main digit loop, we discover the value of each digit    ;;
			;;      by repeated subtraction.  We build up our digit value while         ;;
			;;      subtracting the power-of-10 repeatedly.  We iterate until we go     ;;
			;;      a step too far, and then we add back on power-of-10 to restore      ;;
			;;      the remainder.                                                      ;;
			;;                                                                          ;;
			;;  NOTES                                                                   ;;
			;;      The left-justified variant ignores field width.                     ;;
			;;                                                                          ;;
			;;      The code is fully reentrant.                                        ;;
			;;                                                                          ;;
			;;      This code does not handle numbers which are too large to be         ;;
			;;      displayed in the provided field.  If the number is too large,       ;;
			;;      non-digit characters will be displayed in the initial digit         ;;
			;;      position.  Also, the run time of this routine may get excessively   ;;
			;;      large, depending on the magnitude of the overflow.                  ;;
			;;                                                                          ;;
			;;      When using with PRNUM32, one must either include PRNUM32 before     ;;
			;;      this function, or define the symbol _WITH_PRNUM32.  PRNUM32         ;;
			;;      needs a tiny bit of support from PRNUM16 to handle numbers in       ;;
			;;      the range 65536...99999 correctly.                                  ;;
			;;                                                                          ;;
			;;  CODESIZE                                                                ;;
			;;      73 words, including power-of-10 table                               ;;
			;;      80 words, if compiled with PRNUM32.                                 ;;
			;;                                                                          ;;
			;;      To save code size, you can define the following symbols to omit     ;;
			;;      some variants:                                                      ;;
			;;                                                                          ;;
			;;          _NO_PRNUM16.l:   Disables PRNUM16.l.  Saves 10 words            ;;
			;;          _NO_PRNUM16.b:   Disables PRNUM16.b.  Saves 3 words.            ;;
			;;                                                                          ;;
			;;      Defining both symbols saves 17 words total, because it omits        ;;
			;;      some code shared by both routines.                                  ;;
			;;                                                                          ;;
			;;  STACK USAGE                                                             ;;
			;;      This function uses up to 4 words of stack space.                    ;;
			;;                                                                          ;;
			;;  LICENSE                                                                 ;;
			;;      GNU General Public License, Version 2.0.                            ;;
			;;                                                                          ;;
			;;      This program is free software; you can redistribute it and/or       ;;
			;;      modify it under the terms of the GNU General Public License as      ;;
			;;      published by the Free Software Foundation; either version 2 of the  ;;
			;;      License, or (at your option) any later version.                     ;;
			;;                                                                          ;;
			;;      This program is distributed in the hope that it will be useful,     ;;
			;;      but WITHOUT ANY WARRANTY; without even the implied warranty of      ;;
			;;      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU   ;;
			;;      General Public License for more details.                            ;;
			;;                                                                          ;;
			;;      You should have received a copy of the GNU General Public License   ;;
			;;      along with this program; if not, write to the Free Software         ;;
			;;      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.           ;;
			;; ------------------------------------------------------------------------ ;;
			;;                   Copyright (c) 2003, Joseph Zbiciak                     ;;
			;; ======================================================================== ;;

			    IF (DEFINED PRNUM16) = 0
 0x5174                 PRNUM16 PROC

			    
			        ;; ---------------------------------------------------------------- ;;
			        ;;  PRNUM16.l:  Print unsigned, left-justified.                     ;;
			        ;; ---------------------------------------------------------------- ;;
			    IF (DEFINED _NO_PRNUM16.l) = 0
5174 0275 		@@l:    PSHR    R5              ; save return address
5175 02bd 0001 		@@l1:   MVII    #$1,    R5      ; set R5 to 1 to counteract screen ptr update
			                                ; in the 'find initial power of 10' loop
5177 0272 		        PSHR    R2
5178 02ba 0005 		        MVII    #5,     R2      ; force effective field width to 5.
517a 0200 0005 		        B       @@z2
			    ENDI

			        ;; ---------------------------------------------------------------- ;;
			        ;;  PRNUM16.b:  Print unsigned with leading blanks.                 ;;
			        ;; ---------------------------------------------------------------- ;;
			    IF (DEFINED _NO_PRNUM16.b) = 0
517c 0275 		@@b:    PSHR    R5
517d 01ed 		@@b1:   CLRR    R5              ; let the blank loop do its thing
517e 000f 		        INCR    PC              ; skip the PSHR R5
			    ENDI

			        ;; ---------------------------------------------------------------- ;;
			        ;;  PRNUM16.z:  Print unsigned with leading zeros.                  ;;
			        ;; ---------------------------------------------------------------- ;;
517f 0275 		@@z:    PSHR    R5
5180 0272 		@@z1:   PSHR    R2
5181 0271 		@@z2:   PSHR    R1

			        ;; ---------------------------------------------------------------- ;;
			        ;;  Find the initial power of 10 to use for display.                ;;
			        ;;  Note:  For fields wider than 5, fill the extra spots above 5    ;;
			        ;;  with blanks or zeros as needed.                                 ;;
			        ;; ---------------------------------------------------------------- ;;
5182 02b9 5173 		        MVII    #_PW10+5,R1     ; Point to end of power-of-10 table
5184 0111 		        SUBR    R2,     R1      ; Subtract the field width to get right power
5185 0273 		        PSHR    R3              ; save format word

			    IF ((DEFINED _NO_PRNUM16.l) AND (DEFINED _NO_PRNUM16.b)) = 0
5186 037d 0002 		        CMPI    #2,     R5      ; are we leading with zeros?
5188 0209 0008 		        BNC     @@lblnk         ; no:  then do the loop w/ blanks

			      IF (DEFINED _NO_PRNUM16.l) = 0
518a 01ed 		        CLRR    R5              ; force R5==0
			      ENDI
			    ENDI
518b 02fb 0080 		        ADDI    #$80,   R3      ; yes: do the loop with zeros
518d 0200 0003 		        B       @@lblnk
			    

518f 0263 		@@llp   MVO@    R3,     R4      ; print a blank/zero

			    IF (DEFINED _NO_PRNUM16.l) = 0
5190 012c 		        SUBR    R5,     R4      ; rewind pointer if needed.
			    ENDI

5191 0009 		        INCR    R1              ; get next power of 10
5192 0012 		@@lblnk DECR    R2              ; decrement available digits
5193 0204 0007 		        BEQ     @@ldone
5195 037a 0005 		        CMPI    #5,     R2      ; field too wide?
5197 022d 0009 		        BGE     @@llp           ; just force blanks/zeros 'till we're narrower.
5199 0348 		        CMP@    R1,     R0      ; Is this power of 10 too big?
519a 0229 000c 		        BNC     @@llp           ; Yes:  Put a blank and go to next

519c 02b3 		@@ldone PULR    R3              ; restore format word

			        ;; ---------------------------------------------------------------- ;;
			        ;;  The digit loop prints at least one digit.  It discovers digits  ;;
			        ;;  by repeated subtraction.                                        ;;
			        ;; ---------------------------------------------------------------- ;;
519d 0080 		@@digit TSTR    R0              ; If the number is zero, print zero and leave
519e 020c 0006 		        BNEQ    @@dig1          ; no: print the number

51a0 009d 		        MOVR    R3,     R5      ;\    
51a1 02fd 0080 		        ADDI    #$80,   R5      ; |-- print a 0 there.
51a3 0265 		        MVO@    R5,     R4      ;/    
51a4 0200 000e 		        B       @@done

			    IF (DEFINED PRNUM32) OR (DEFINED _WITH_PRNUM32)
			@@dig1: MOVR    R3,     R5      ; for first digit only: check to see if 
			        BPL     @@cont          ; we need to add '5'.  
			        ADDI    #$80+4*8,R5     ; start our digit as one just before '5'
			        B       @@spcl
			    ELSE
 0x51a6                 @@dig1:
			    ENDI
			    
51a6 009d 		@@nxdig MOVR    R3,     R5      ; save display format word
51a7 02fd 0078 		@@cont: ADDI    #$80-8, R5      ; start our digit as one just before '0'
 0x51a9                 @@spcl:
			 
			        ;; ---------------------------------------------------------------- ;;
			        ;;  Divide by repeated subtraction.  This divide is constructed     ;;
			        ;;  to go "one step too far" and then back up.                      ;;
			        ;; ---------------------------------------------------------------- ;;
51a9 02fd 0008 		@@div:  ADDI    #8,     R5      ; increment our digit
51ab 0308 		        SUB@    R1,     R0      ; subtract power of 10
51ac 0221 0004 		        BC      @@div           ; loop until we go too far
51ae 02c8 		        ADD@    R1,     R0      ; add back the extra power of 10.

51af 0265 		        MVO@    R5,     R4      ; display the digit.

51b0 0009 		        INCR    R1              ; point to next power of 10
51b1 0012 		        DECR    R2              ; any room left in field?
51b2 0223 000d 		        BPL     @@nxdig         ; keep going until R2 < 0.

51b4 02b1 		@@done: PULR    R1              ; restore R1
51b5 02b2 		        PULR    R2              ; restore R2
51b6 02b7 		        PULR    PC              ; return

			        ENDP
			    ENDI
			        
			;; ======================================================================== ;;
			;;  End of File:  prnum16.asm                                               ;;
			;; ======================================================================== ;;
			            INCLUDE "library/hexdisp.asm"
			;;==========================================================================;;
			;;  Useful Routines                                                         ;;
			;;  Copyright 1999-2002, Joe Zbiciak.                                       ;;
			;;                                                                          ;;
			;;  This file contains a number of useful routines that you're welcome      ;;
			;;  to use in your own software.  Please keep in mind that these routines   ;;
			;;  are licensed under the GNU General Public License, and so if you plan   ;;
			;;  to distribute a program which incorporates these routines, it too must  ;;
			;;  be distributed under the GNU General Public License.                    ;;
			;;==========================================================================;;

			;;==========================================================================;;
			;;  NOTE:  IF YOU NEED ONLY HEX16, THAT IS CONTAINED IN A SEPARATE FILE     ;;
			;;  CALLED "hex16.asm".  THIS FILE AND THAT ONE CANNOT BE USED TOGETHER.    ;;
			;;==========================================================================;;

			;; ======================================================================== ;;
			;;  HEX16  -- Display a 4-digit hex number on the screen                    ;;
			;;  HEX12M -- Display a 3-digit hex number on the screen (MSBs)             ;;
			;;  HEX8M  -- Display a 2-digit hex number on the screen (MSBs)             ;;
			;;  HEX4M  -- Display a 1-digit hex number on the screen (MSBs)             ;;
			;;  HEX12  -- Display a 3-digit hex number on the screen (LSBs)             ;;
			;;  HEX8   -- Display a 2-digit hex number on the screen (LSBs)             ;;
			;;  HEX4   -- Display a 1-digit hex number on the screen (LSBs)             ;;
			;;                                                                          ;;
			;;  INPUTS:                                                                 ;;
			;;      R0 -- Hex number                                                    ;;
			;;      R1 -- Color mask                                                    ;;
			;;      R4 -- Screen offset                                                 ;;
			;;                                                                          ;;
			;;  OUTPUTS:                                                                ;;
			;;      R0 -- trashed                                                       ;;
			;;      R1 -- unmodified                                                    ;;
			;;      R2 -- trashed                                                       ;;
			;;      R3 -- zeroed                                                        ;;
			;;      R4 -- points just to right of string                                ;;
			;; ======================================================================== ;;
 0x51b7                 HEX16   PROC
51b7 02bb 0004 		        MVII    #4,     R3
51b9 0200 0010 		        B       @@start
 0x51bb                 HEX12: 
51bb 004c 		        SLL     R0,     2
51bc 004c 		        SLL     R0,     2
 0x51bd                 HEX12M:
51bd 02bb 0003 		        MVII    #3,     R3
51bf 0200 000a 		        B       @@start
 0x51c1                 HEX8:
51c1 0040 		        SWAP    R0
 0x51c2                 HEX8M:
51c2 02bb 0002 		        MVII    #2,     R3
51c4 0200 0005 		        B       @@start
 0x51c6                 HEX4:
51c6 0040 		        SWAP    R0
51c7 004c 		        SLL     R0,     2
51c8 004c 		        SLL     R0,     2
 0x51c9                 HEX4M:
51c9 02bb 0001 		        MVII    #1,     R3

 0x51cb                 @@start:
			        ; Rotate R0 left by 3, so that our digit will be in the correct
			        ; position within the screen format word.
51cb 0082 		        MOVR    R0,     R2
51cc 005e 		        SLLC    R2,     2
51cd 0054 		        RLC     R0,     2       ; First, rotate by two bits...
51ce 005a 		        SLLC    R2,     1
51cf 0050 		        RLC     R0,     1       ; ... and then by one more.
 0x51d0                 @@loop:
			        ; Rotate R0 left by 4, so that we can cycle through each digit
			        ; one at a time.
51d0 0082 		        MOVR    R0,     R2
51d1 005e 		        SLLC    R2,     2
51d2 0054 		        RLC     R0,     2       ; First, rotate by two bits...
51d3 005e 		        SLLC    R2,     2
51d4 0054 		        RLC     R0,     2       ; ... and then by two more.

			        ; Mask out a single hex digit
51d5 0082 		        MOVR    R0,     R2
51d6 03ba 0078 		        ANDI    #$78,   R2

			        ; Is it A..F?  If so, add an offset so that the correct ASCII
			        ; value is selected.  Otherwise do nothing special.
51d8 037a 0050 		        CMPI    #$50,   R2      ; $50 is $A shifted left by 3.  
51da 0205 0002 		        BLT     @@digit                                          
51dc 02fa 0038 		        ADDI    #$38,   R2      ; If the digit >= A, add 6 << 3.
 0x51de                 @@digit:
51de 02fa 0080 		        ADDI    #$80,   R2      ; Generate proper GROM index.     
51e0 01ca 		        XORR    R1,     R2      ; Merge in the screen format word 
51e1 0262 		        MVO@    R2,     R4      ; Display the digit to the screen.

51e2 0013 		        DECR    R3              ; Iterate up to three more times.
51e3 022c 0014 		        BNE     @@loop

51e5 00af 		        JR      R5
			        ENDP
			        
			;* ======================================================================== *;
			;*  This program is free software; you can redistribute it and/or modify    *;
			;*  it under the terms of the GNU General Public License as published by    *;
			;*  the Free Software Foundation; either version 2 of the License, or       *;
			;*  (at your option) any later version.                                     *;
			;*                                                                          *;
			;*  This program is distributed in the hope that it will be useful,         *;
			;*  but WITHOUT ANY WARRANTY; without even the implied warranty of          *;
			;*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU       *;
			;*  General Public License for more details.                                *;
			;*                                                                          *;
			;*  You should have received a copy of the GNU General Public License       *;
			;*  along with this program; if not, write to the Free Software             *;
			;*  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.               *;
			;* ======================================================================== *;
			;*                Copyright (c) 1999-2002, Joseph Zbiciak                   *;
			;* ======================================================================== *;
 ERROR SUMMARY - ERRORS DETECTED 0
               -  WARNINGS       0
